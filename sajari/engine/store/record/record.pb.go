// Code generated by protoc-gen-go.
// source: sajari/engine/store/record/record.proto
// DO NOT EDIT!

/*
Package sajari_engine_store_record is a generated protocol buffer package.

It is generated from these files:
	sajari/engine/store/record/record.proto

It has these top-level messages:
	ExistsResponse
	Transform
	Record
	Records
	AddResponse
	GetResponse
	DeleteResponse
	PatchResponse
	Keys
	KeysValues
	SetRequest
	SetResponse
	IncrementRequest
	IncrementResponse
	KeyScores
*/
package sajari_engine_store_record

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import sajari_engine "github.com/sajari/protogen-go/sajari/engine"
import sajari_engine1 "github.com/sajari/protogen-go/sajari/engine"
import sajari_rpc "github.com/sajari/protogen-go/sajari/rpc"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ExistsResponse struct {
	Status []*sajari_rpc.Status `protobuf:"bytes,1,rep,name=status" json:"status,omitempty"`
}

func (m *ExistsResponse) Reset()                    { *m = ExistsResponse{} }
func (m *ExistsResponse) String() string            { return proto.CompactTextString(m) }
func (*ExistsResponse) ProtoMessage()               {}
func (*ExistsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ExistsResponse) GetStatus() []*sajari_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Transform is a representation of a transform process which is applied to a record
// before it is added.
type Transform struct {
	// Identifier unique identifies a transform
	Identifier string `protobuf:"bytes,1,opt,name=identifier" json:"identifier,omitempty"`
}

func (m *Transform) Reset()                    { *m = Transform{} }
func (m *Transform) String() string            { return proto.CompactTextString(m) }
func (*Transform) ProtoMessage()               {}
func (*Transform) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Transform) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

// Record is a single record made up of key-value pairs.
type Record struct {
	// A map of key-value pairs.
	Values map[string]*sajari_engine.Value `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Record) Reset()                    { *m = Record{} }
func (m *Record) String() string            { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()               {}
func (*Record) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Record) GetValues() map[string]*sajari_engine.Value {
	if m != nil {
		return m.Values
	}
	return nil
}

// Records is a message which represents a list of records.
type Records struct {
	// The list of records.
	Records []*Record `protobuf:"bytes,1,rep,name=records" json:"records,omitempty"`
	// Transforms is a list of transformations to be applied to the records
	// before they are added.
	Transforms []*Transform `protobuf:"bytes,2,rep,name=transforms" json:"transforms,omitempty"`
}

func (m *Records) Reset()                    { *m = Records{} }
func (m *Records) String() string            { return proto.CompactTextString(m) }
func (*Records) ProtoMessage()               {}
func (*Records) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Records) GetRecords() []*Record {
	if m != nil {
		return m.Records
	}
	return nil
}

func (m *Records) GetTransforms() []*Transform {
	if m != nil {
		return m.Transforms
	}
	return nil
}

// AddResponse is returned from Add.
type AddResponse struct {
	// Keys for the inserted records.
	Keys []*sajari_engine1.Key `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	// Status for each insert.
	Status []*sajari_rpc.Status `protobuf:"bytes,2,rep,name=status" json:"status,omitempty"`
}

func (m *AddResponse) Reset()                    { *m = AddResponse{} }
func (m *AddResponse) String() string            { return proto.CompactTextString(m) }
func (*AddResponse) ProtoMessage()               {}
func (*AddResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *AddResponse) GetKeys() []*sajari_engine1.Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *AddResponse) GetStatus() []*sajari_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// GetResponse is returned from Get.
type GetResponse struct {
	Records []*Record `protobuf:"bytes,1,rep,name=records" json:"records,omitempty"`
	// Status for each get.
	Status []*sajari_rpc.Status `protobuf:"bytes,2,rep,name=status" json:"status,omitempty"`
}

func (m *GetResponse) Reset()                    { *m = GetResponse{} }
func (m *GetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()               {}
func (*GetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetResponse) GetRecords() []*Record {
	if m != nil {
		return m.Records
	}
	return nil
}

func (m *GetResponse) GetStatus() []*sajari_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// DeleteResponse is returned from Delete.
type DeleteResponse struct {
	Status []*sajari_rpc.Status `protobuf:"bytes,1,rep,name=status" json:"status,omitempty"`
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DeleteResponse) GetStatus() []*sajari_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type PatchResponse struct {
	Status []*sajari_rpc.Status `protobuf:"bytes,1,rep,name=status" json:"status,omitempty"`
}

func (m *PatchResponse) Reset()                    { *m = PatchResponse{} }
func (m *PatchResponse) String() string            { return proto.CompactTextString(m) }
func (*PatchResponse) ProtoMessage()               {}
func (*PatchResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PatchResponse) GetStatus() []*sajari_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Keys is a list of keys.
type Keys struct {
	Keys []*sajari_engine1.Key `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *Keys) Reset()                    { *m = Keys{} }
func (m *Keys) String() string            { return proto.CompactTextString(m) }
func (*Keys) ProtoMessage()               {}
func (*Keys) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Keys) GetKeys() []*sajari_engine1.Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

type KeysValues struct {
	KeysValues []*KeysValues_KeyValues `protobuf:"bytes,1,rep,name=keys_values,json=keysValues" json:"keys_values,omitempty"`
}

func (m *KeysValues) Reset()                    { *m = KeysValues{} }
func (m *KeysValues) String() string            { return proto.CompactTextString(m) }
func (*KeysValues) ProtoMessage()               {}
func (*KeysValues) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *KeysValues) GetKeysValues() []*KeysValues_KeyValues {
	if m != nil {
		return m.KeysValues
	}
	return nil
}

type KeysValues_KeyValues struct {
	// The key used to identify the record to be patched.
	Key *sajari_engine1.Key `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Map of key-value pairs to patch data in the collection record.  The
	// value should be a JSON-encoded representation of an engine-recognised
	// type.  Null is used to clear a value in the collection.
	Values map[string]*KeysValues_KeyValues_Value `protobuf:"bytes,2,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *KeysValues_KeyValues) Reset()                    { *m = KeysValues_KeyValues{} }
func (m *KeysValues_KeyValues) String() string            { return proto.CompactTextString(m) }
func (*KeysValues_KeyValues) ProtoMessage()               {}
func (*KeysValues_KeyValues) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *KeysValues_KeyValues) GetKey() *sajari_engine1.Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KeysValues_KeyValues) GetValues() map[string]*KeysValues_KeyValues_Value {
	if m != nil {
		return m.Values
	}
	return nil
}

// Value is a patching value, which can exhibit a number of different
// behaviours.
type KeysValues_KeyValues_Value struct {
	// Types that are valid to be assigned to Value:
	//	*KeysValues_KeyValues_Value_Set
	//	*KeysValues_KeyValues_Value_Increment
	//	*KeysValues_KeyValues_Value_Append
	Value isKeysValues_KeyValues_Value_Value `protobuf_oneof:"value"`
}

func (m *KeysValues_KeyValues_Value) Reset()         { *m = KeysValues_KeyValues_Value{} }
func (m *KeysValues_KeyValues_Value) String() string { return proto.CompactTextString(m) }
func (*KeysValues_KeyValues_Value) ProtoMessage()    {}
func (*KeysValues_KeyValues_Value) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{9, 0, 0}
}

type isKeysValues_KeyValues_Value_Value interface {
	isKeysValues_KeyValues_Value_Value()
}

type KeysValues_KeyValues_Value_Set struct {
	Set *sajari_engine.Value `protobuf:"bytes,1,opt,name=set,oneof"`
}
type KeysValues_KeyValues_Value_Increment struct {
	Increment *sajari_engine.Value `protobuf:"bytes,2,opt,name=increment,oneof"`
}
type KeysValues_KeyValues_Value_Append struct {
	Append *sajari_engine.Value `protobuf:"bytes,3,opt,name=append,oneof"`
}

func (*KeysValues_KeyValues_Value_Set) isKeysValues_KeyValues_Value_Value()       {}
func (*KeysValues_KeyValues_Value_Increment) isKeysValues_KeyValues_Value_Value() {}
func (*KeysValues_KeyValues_Value_Append) isKeysValues_KeyValues_Value_Value()    {}

func (m *KeysValues_KeyValues_Value) GetValue() isKeysValues_KeyValues_Value_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *KeysValues_KeyValues_Value) GetSet() *sajari_engine.Value {
	if x, ok := m.GetValue().(*KeysValues_KeyValues_Value_Set); ok {
		return x.Set
	}
	return nil
}

func (m *KeysValues_KeyValues_Value) GetIncrement() *sajari_engine.Value {
	if x, ok := m.GetValue().(*KeysValues_KeyValues_Value_Increment); ok {
		return x.Increment
	}
	return nil
}

func (m *KeysValues_KeyValues_Value) GetAppend() *sajari_engine.Value {
	if x, ok := m.GetValue().(*KeysValues_KeyValues_Value_Append); ok {
		return x.Append
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*KeysValues_KeyValues_Value) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _KeysValues_KeyValues_Value_OneofMarshaler, _KeysValues_KeyValues_Value_OneofUnmarshaler, _KeysValues_KeyValues_Value_OneofSizer, []interface{}{
		(*KeysValues_KeyValues_Value_Set)(nil),
		(*KeysValues_KeyValues_Value_Increment)(nil),
		(*KeysValues_KeyValues_Value_Append)(nil),
	}
}

func _KeysValues_KeyValues_Value_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*KeysValues_KeyValues_Value)
	// value
	switch x := m.Value.(type) {
	case *KeysValues_KeyValues_Value_Set:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Set); err != nil {
			return err
		}
	case *KeysValues_KeyValues_Value_Increment:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Increment); err != nil {
			return err
		}
	case *KeysValues_KeyValues_Value_Append:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Append); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("KeysValues_KeyValues_Value.Value has unexpected type %T", x)
	}
	return nil
}

func _KeysValues_KeyValues_Value_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*KeysValues_KeyValues_Value)
	switch tag {
	case 1: // value.set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sajari_engine.Value)
		err := b.DecodeMessage(msg)
		m.Value = &KeysValues_KeyValues_Value_Set{msg}
		return true, err
	case 2: // value.increment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sajari_engine.Value)
		err := b.DecodeMessage(msg)
		m.Value = &KeysValues_KeyValues_Value_Increment{msg}
		return true, err
	case 3: // value.append
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sajari_engine.Value)
		err := b.DecodeMessage(msg)
		m.Value = &KeysValues_KeyValues_Value_Append{msg}
		return true, err
	default:
		return false, nil
	}
}

func _KeysValues_KeyValues_Value_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*KeysValues_KeyValues_Value)
	// value
	switch x := m.Value.(type) {
	case *KeysValues_KeyValues_Value_Set:
		s := proto.Size(x.Set)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KeysValues_KeyValues_Value_Increment:
		s := proto.Size(x.Increment)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KeysValues_KeyValues_Value_Append:
		s := proto.Size(x.Append)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SetRequest struct {
	KeysScores []*KeyScores `protobuf:"bytes,1,rep,name=keys_scores,json=keysScores" json:"keys_scores,omitempty"`
}

func (m *SetRequest) Reset()                    { *m = SetRequest{} }
func (m *SetRequest) String() string            { return proto.CompactTextString(m) }
func (*SetRequest) ProtoMessage()               {}
func (*SetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SetRequest) GetKeysScores() []*KeyScores {
	if m != nil {
		return m.KeysScores
	}
	return nil
}

type SetResponse struct {
	Status []*sajari_rpc.Status `protobuf:"bytes,1,rep,name=status" json:"status,omitempty"`
}

func (m *SetResponse) Reset()                    { *m = SetResponse{} }
func (m *SetResponse) String() string            { return proto.CompactTextString(m) }
func (*SetResponse) ProtoMessage()               {}
func (*SetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *SetResponse) GetStatus() []*sajari_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type IncrementRequest struct {
	KeysScores []*KeyScores `protobuf:"bytes,1,rep,name=keys_scores,json=keysScores" json:"keys_scores,omitempty"`
}

func (m *IncrementRequest) Reset()                    { *m = IncrementRequest{} }
func (m *IncrementRequest) String() string            { return proto.CompactTextString(m) }
func (*IncrementRequest) ProtoMessage()               {}
func (*IncrementRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *IncrementRequest) GetKeysScores() []*KeyScores {
	if m != nil {
		return m.KeysScores
	}
	return nil
}

// Increment response is
type IncrementResponse struct {
	Status []*sajari_rpc.Status `protobuf:"bytes,1,rep,name=status" json:"status,omitempty"`
}

func (m *IncrementResponse) Reset()                    { *m = IncrementResponse{} }
func (m *IncrementResponse) String() string            { return proto.CompactTextString(m) }
func (*IncrementResponse) ProtoMessage()               {}
func (*IncrementResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *IncrementResponse) GetStatus() []*sajari_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type KeyScores struct {
	// Record identifier key.
	Key *sajari_engine1.Key `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Scores to update.
	Scores []*KeyScores_Score `protobuf:"bytes,2,rep,name=scores" json:"scores,omitempty"`
}

func (m *KeyScores) Reset()                    { *m = KeyScores{} }
func (m *KeyScores) String() string            { return proto.CompactTextString(m) }
func (*KeyScores) ProtoMessage()               {}
func (*KeyScores) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *KeyScores) GetKey() *sajari_engine1.Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KeyScores) GetScores() []*KeyScores_Score {
	if m != nil {
		return m.Scores
	}
	return nil
}

// Score values for an array of terms.
type KeyScores_Score struct {
	// Terms to score.
	Terms []string `protobuf:"bytes,1,rep,name=terms" json:"terms,omitempty"`
	// Count of interactions (uint16).
	Count int32 `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
	// Score for interactions.
	Score float32 `protobuf:"fixed32,3,opt,name=score" json:"score,omitempty"`
}

func (m *KeyScores_Score) Reset()                    { *m = KeyScores_Score{} }
func (m *KeyScores_Score) String() string            { return proto.CompactTextString(m) }
func (*KeyScores_Score) ProtoMessage()               {}
func (*KeyScores_Score) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

func (m *KeyScores_Score) GetTerms() []string {
	if m != nil {
		return m.Terms
	}
	return nil
}

func (m *KeyScores_Score) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *KeyScores_Score) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func init() {
	proto.RegisterType((*ExistsResponse)(nil), "sajari.engine.store.record.ExistsResponse")
	proto.RegisterType((*Transform)(nil), "sajari.engine.store.record.Transform")
	proto.RegisterType((*Record)(nil), "sajari.engine.store.record.Record")
	proto.RegisterType((*Records)(nil), "sajari.engine.store.record.Records")
	proto.RegisterType((*AddResponse)(nil), "sajari.engine.store.record.AddResponse")
	proto.RegisterType((*GetResponse)(nil), "sajari.engine.store.record.GetResponse")
	proto.RegisterType((*DeleteResponse)(nil), "sajari.engine.store.record.DeleteResponse")
	proto.RegisterType((*PatchResponse)(nil), "sajari.engine.store.record.PatchResponse")
	proto.RegisterType((*Keys)(nil), "sajari.engine.store.record.Keys")
	proto.RegisterType((*KeysValues)(nil), "sajari.engine.store.record.KeysValues")
	proto.RegisterType((*KeysValues_KeyValues)(nil), "sajari.engine.store.record.KeysValues.KeyValues")
	proto.RegisterType((*KeysValues_KeyValues_Value)(nil), "sajari.engine.store.record.KeysValues.KeyValues.Value")
	proto.RegisterType((*SetRequest)(nil), "sajari.engine.store.record.SetRequest")
	proto.RegisterType((*SetResponse)(nil), "sajari.engine.store.record.SetResponse")
	proto.RegisterType((*IncrementRequest)(nil), "sajari.engine.store.record.IncrementRequest")
	proto.RegisterType((*IncrementResponse)(nil), "sajari.engine.store.record.IncrementResponse")
	proto.RegisterType((*KeyScores)(nil), "sajari.engine.store.record.KeyScores")
	proto.RegisterType((*KeyScores_Score)(nil), "sajari.engine.store.record.KeyScores.Score")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Store service

type StoreClient interface {
	// Add creates new records in the collection returning a key for each
	// stored record.  The key can then be used in subsequent requests to
	// get/delete/patch.
	Add(ctx context.Context, in *Records, opts ...grpc.CallOption) (*AddResponse, error)
	// Get retrieves the records corresponding to the listed keys.
	Get(ctx context.Context, in *Keys, opts ...grpc.CallOption) (*GetResponse, error)
	// Delete removes the records corresponding to the listed keys.
	Delete(ctx context.Context, in *Keys, opts ...grpc.CallOption) (*DeleteResponse, error)
	// Patch applies key-value updates to records corresponding to
	// keys.
	Patch(ctx context.Context, in *KeysValues, opts ...grpc.CallOption) (*PatchResponse, error)
	// Exists
	Exists(ctx context.Context, in *Keys, opts ...grpc.CallOption) (*ExistsResponse, error)
}

type storeClient struct {
	cc *grpc.ClientConn
}

func NewStoreClient(cc *grpc.ClientConn) StoreClient {
	return &storeClient{cc}
}

func (c *storeClient) Add(ctx context.Context, in *Records, opts ...grpc.CallOption) (*AddResponse, error) {
	out := new(AddResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.store.record.Store/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Get(ctx context.Context, in *Keys, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.store.record.Store/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Delete(ctx context.Context, in *Keys, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.store.record.Store/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Patch(ctx context.Context, in *KeysValues, opts ...grpc.CallOption) (*PatchResponse, error) {
	out := new(PatchResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.store.record.Store/Patch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Exists(ctx context.Context, in *Keys, opts ...grpc.CallOption) (*ExistsResponse, error) {
	out := new(ExistsResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.store.record.Store/Exists", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Store service

type StoreServer interface {
	// Add creates new records in the collection returning a key for each
	// stored record.  The key can then be used in subsequent requests to
	// get/delete/patch.
	Add(context.Context, *Records) (*AddResponse, error)
	// Get retrieves the records corresponding to the listed keys.
	Get(context.Context, *Keys) (*GetResponse, error)
	// Delete removes the records corresponding to the listed keys.
	Delete(context.Context, *Keys) (*DeleteResponse, error)
	// Patch applies key-value updates to records corresponding to
	// keys.
	Patch(context.Context, *KeysValues) (*PatchResponse, error)
	// Exists
	Exists(context.Context, *Keys) (*ExistsResponse, error)
}

func RegisterStoreServer(s *grpc.Server, srv StoreServer) {
	s.RegisterService(&_Store_serviceDesc, srv)
}

func _Store_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Records)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.store.record.Store/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Add(ctx, req.(*Records))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Keys)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.store.record.Store/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Get(ctx, req.(*Keys))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Keys)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.store.record.Store/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Delete(ctx, req.(*Keys))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysValues)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.store.record.Store/Patch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Patch(ctx, req.(*KeysValues))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Keys)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.store.record.Store/Exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Exists(ctx, req.(*Keys))
	}
	return interceptor(ctx, in, info, handler)
}

var _Store_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sajari.engine.store.record.Store",
	HandlerType: (*StoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _Store_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Store_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Store_Delete_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _Store_Patch_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _Store_Exists_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sajari/engine/store/record/record.proto",
}

// Client API for Score service

type ScoreClient interface {
	// SetScores sets record-term instance pos/neg scores in the Store.
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
	// IncrScores incrementally updates record-term instance pos/neg scores in the Store.
	Increment(ctx context.Context, in *IncrementRequest, opts ...grpc.CallOption) (*IncrementResponse, error)
}

type scoreClient struct {
	cc *grpc.ClientConn
}

func NewScoreClient(cc *grpc.ClientConn) ScoreClient {
	return &scoreClient{cc}
}

func (c *scoreClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	out := new(SetResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.store.record.Score/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoreClient) Increment(ctx context.Context, in *IncrementRequest, opts ...grpc.CallOption) (*IncrementResponse, error) {
	out := new(IncrementResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.store.record.Score/Increment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Score service

type ScoreServer interface {
	// SetScores sets record-term instance pos/neg scores in the Store.
	Set(context.Context, *SetRequest) (*SetResponse, error)
	// IncrScores incrementally updates record-term instance pos/neg scores in the Store.
	Increment(context.Context, *IncrementRequest) (*IncrementResponse, error)
}

func RegisterScoreServer(s *grpc.Server, srv ScoreServer) {
	s.RegisterService(&_Score_serviceDesc, srv)
}

func _Score_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoreServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.store.record.Score/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoreServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Score_Increment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoreServer).Increment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.store.record.Score/Increment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoreServer).Increment(ctx, req.(*IncrementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Score_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sajari.engine.store.record.Score",
	HandlerType: (*ScoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _Score_Set_Handler,
		},
		{
			MethodName: "Increment",
			Handler:    _Score_Increment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sajari/engine/store/record/record.proto",
}

func init() { proto.RegisterFile("sajari/engine/store/record/record.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 731 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0x5e, 0x9a, 0x25, 0x53, 0x4f, 0xc4, 0x34, 0xac, 0x49, 0x94, 0x5c, 0xa0, 0x2a, 0xb0, 0xad,
	0x6c, 0x90, 0xa2, 0x82, 0x10, 0x3f, 0x95, 0xd0, 0x80, 0xfd, 0x69, 0x48, 0x0c, 0x67, 0xea, 0xc5,
	0x6e, 0x50, 0x48, 0x3c, 0x16, 0xba, 0x25, 0x9d, 0xed, 0x02, 0x7d, 0x09, 0xde, 0x00, 0x09, 0x5e,
	0x83, 0x3b, 0x2e, 0x79, 0x2a, 0x50, 0x6c, 0x37, 0x4d, 0xcb, 0x48, 0x7f, 0xc6, 0x55, 0x1c, 0xfb,
	0x3b, 0xe7, 0x7c, 0x39, 0xfe, 0xbe, 0xa3, 0xc0, 0x1a, 0xf3, 0x3f, 0xf8, 0x34, 0xaa, 0x93, 0xf8,
	0x7d, 0x14, 0x93, 0x3a, 0xe3, 0x09, 0x25, 0x75, 0x4a, 0x82, 0x84, 0x86, 0xea, 0xe1, 0x76, 0x68,
	0xc2, 0x13, 0x64, 0x4b, 0xa0, 0x2b, 0x81, 0xae, 0x00, 0xba, 0x12, 0x61, 0x5f, 0x1f, 0x4e, 0xf2,
	0xd1, 0x3f, 0xed, 0x12, 0x19, 0x66, 0x5f, 0x1b, 0x3e, 0x6a, 0x93, 0xde, 0xc8, 0x01, 0xed, 0x04,
	0x75, 0xc6, 0x7d, 0xde, 0x65, 0xf2, 0xc0, 0x69, 0xc2, 0xe2, 0xd6, 0xe7, 0x88, 0x71, 0x86, 0x09,
	0xeb, 0x24, 0x31, 0x23, 0x68, 0x1d, 0x4c, 0x89, 0xa8, 0x68, 0x55, 0xbd, 0x66, 0x35, 0x90, 0xab,
	0xb8, 0xd0, 0x4e, 0xe0, 0x7a, 0xe2, 0x04, 0x2b, 0x84, 0xb3, 0x01, 0xe5, 0x43, 0xea, 0xc7, 0xec,
	0x38, 0xa1, 0x67, 0xe8, 0x06, 0x40, 0x14, 0x92, 0x98, 0x47, 0xc7, 0x11, 0xa1, 0x15, 0xad, 0xaa,
	0xd5, 0xca, 0x38, 0xb7, 0xe3, 0x7c, 0xd7, 0xc0, 0xc4, 0xe2, 0x13, 0xd0, 0x36, 0x98, 0x82, 0x76,
	0xbf, 0x86, 0xeb, 0xfe, 0xfb, 0x7b, 0x5d, 0x19, 0xe3, 0xb6, 0x44, 0xc0, 0x56, 0xcc, 0x69, 0x0f,
	0xab, 0x68, 0xfb, 0x35, 0x58, 0xb9, 0x6d, 0xb4, 0x04, 0x7a, 0x9b, 0xf4, 0x54, 0xe9, 0x74, 0x89,
	0xd6, 0xc1, 0x10, 0xd0, 0x4a, 0xa9, 0xaa, 0xd5, 0xac, 0xc6, 0xf2, 0x48, 0x1d, 0x11, 0x8c, 0x25,
	0xe4, 0x49, 0xe9, 0x91, 0xe6, 0x7c, 0xd1, 0x60, 0x41, 0xd6, 0x63, 0xa8, 0x09, 0x0b, 0x92, 0x41,
	0x9f, 0xa5, 0x33, 0x9e, 0x25, 0xee, 0x87, 0xa0, 0x2d, 0x00, 0xde, 0x6f, 0x0d, 0xab, 0x94, 0x44,
	0x82, 0x95, 0xa2, 0x04, 0x59, 0x23, 0x71, 0x2e, 0xd0, 0xf1, 0xc1, 0xda, 0x0c, 0xc3, 0xec, 0x72,
	0x56, 0x61, 0xbe, 0x4d, 0x7a, 0x7f, 0x5d, 0x8d, 0xca, 0xb7, 0x4f, 0x7a, 0x58, 0x9c, 0xe7, 0x2e,
	0xb1, 0x34, 0xf6, 0x12, 0x3f, 0x81, 0xb5, 0x43, 0x78, 0x56, 0xe2, 0x72, 0x9f, 0x3d, 0x4d, 0xe1,
	0x26, 0x2c, 0xbe, 0x24, 0xa7, 0x84, 0x93, 0x99, 0xb4, 0xf7, 0x14, 0xae, 0x1c, 0xf8, 0x3c, 0x38,
	0x99, 0x29, 0xd8, 0x85, 0xf9, 0xfd, 0xb4, 0x4f, 0x13, 0xf6, 0xd3, 0xf9, 0xad, 0x03, 0xa4, 0x01,
	0x52, 0x6d, 0xe8, 0x0d, 0x58, 0xe9, 0xf6, 0xdb, 0x21, 0x11, 0xdf, 0x2b, 0xea, 0xd3, 0x20, 0x38,
	0x5d, 0xca, 0x15, 0x86, 0x76, 0xb6, 0x6b, 0x7f, 0xd5, 0xa1, 0x9c, 0x9d, 0xa0, 0x5b, 0x03, 0x25,
	0x5f, 0x4c, 0x4b, 0xa8, 0xfb, 0x30, 0xb3, 0x91, 0x6c, 0x76, 0x73, 0x5a, 0x06, 0x17, 0x9a, 0xea,
	0x9b, 0x06, 0x86, 0xd8, 0x47, 0x35, 0xd0, 0x19, 0xe1, 0x8a, 0xc5, 0x85, 0xde, 0xd9, 0x9d, 0xc3,
	0x29, 0x04, 0x3d, 0x80, 0x72, 0x14, 0x07, 0x94, 0x9c, 0x91, 0x98, 0x17, 0x79, 0x6d, 0x77, 0x0e,
	0x0f, 0x80, 0xc8, 0x05, 0xd3, 0xef, 0x74, 0x48, 0x1c, 0x56, 0xf4, 0xc2, 0x10, 0x85, 0x7a, 0xbe,
	0xa0, 0xdc, 0x6c, 0x9f, 0x8f, 0xf3, 0xfd, 0xab, 0x61, 0xdf, 0x3f, 0x9c, 0xad, 0x31, 0xf9, 0xc9,
	0x70, 0x08, 0xe0, 0xa5, 0x2e, 0x39, 0xef, 0x12, 0xc6, 0xd1, 0xb6, 0x12, 0x00, 0x0b, 0x12, 0x9a,
	0x09, 0x60, 0x65, 0x4c, 0x15, 0x4f, 0x80, 0xe5, 0xad, 0xcb, 0xb5, 0xf3, 0x18, 0x2c, 0x2f, 0xe7,
	0xbd, 0x69, 0x24, 0x7c, 0x04, 0x4b, 0x7b, 0xfd, 0x4e, 0xfe, 0x6f, 0x5a, 0xcf, 0xe0, 0x6a, 0x2e,
	0xf7, 0x0c, 0xe4, 0x7e, 0x6a, 0x42, 0xcd, 0x32, 0xdd, 0x84, 0x6a, 0x7e, 0x01, 0xa6, 0xe2, 0x2d,
	0xd5, 0xbc, 0x31, 0x11, 0x6f, 0x57, 0x3c, 0xb0, 0x0a, 0xb5, 0xf7, 0xc0, 0x10, 0x1b, 0x68, 0x19,
	0x0c, 0x4e, 0xd2, 0xd1, 0x9b, 0x92, 0x2d, 0x63, 0xf9, 0x92, 0xee, 0x06, 0x49, 0x57, 0x69, 0xd4,
	0xc0, 0xf2, 0x25, 0xdd, 0x15, 0xe1, 0x42, 0x86, 0x25, 0x2c, 0x5f, 0x1a, 0x3f, 0x74, 0x30, 0xbc,
	0xb4, 0x26, 0xf2, 0x40, 0xdf, 0x0c, 0x43, 0x74, 0x73, 0xfc, 0x20, 0x64, 0xf6, 0x5a, 0x11, 0x28,
	0x3f, 0xca, 0x0f, 0x40, 0xdf, 0x21, 0x1c, 0x55, 0xc7, 0x49, 0xb3, 0x38, 0x63, 0x7e, 0x72, 0xb7,
	0xc0, 0x94, 0xf3, 0x74, 0x82, 0xa4, 0xeb, 0x45, 0x88, 0x91, 0xa9, 0x7c, 0x04, 0x86, 0x98, 0xb4,
	0x68, 0x75, 0x32, 0x1b, 0xd9, 0xb7, 0x8b, 0x70, 0xc3, 0x43, 0xbb, 0x05, 0xa6, 0xfc, 0xff, 0xb8,
	0x2c, 0xe7, 0xe1, 0xbf, 0x98, 0xc6, 0x2f, 0xad, 0x2f, 0x84, 0x16, 0xe8, 0x1e, 0xe1, 0xc5, 0xdc,
	0x07, 0xce, 0x2e, 0xee, 0x76, 0xde, 0xab, 0x27, 0x50, 0xce, 0x3c, 0x82, 0xee, 0x14, 0x45, 0x8d,
	0xda, 0xd4, 0xbe, 0x3b, 0x21, 0x5a, 0x56, 0x7a, 0x67, 0x8a, 0x5f, 0xb5, 0xfb, 0x7f, 0x02, 0x00,
	0x00, 0xff, 0xff, 0xa1, 0x0e, 0x7b, 0x8a, 0x3e, 0x0a, 0x00, 0x00,
}
