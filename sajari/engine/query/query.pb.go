// Code generated by protoc-gen-go.
// source: sajari/engine/query/query.proto
// DO NOT EDIT!

/*
Package sajari_engine_query is a generated protocol buffer package.

It is generated from these files:
	sajari/engine/query/query.proto

It has these top-level messages:
	SearchRequest
	Transform
	Term
	EvaluateRequest
	SubstituteRequest
	Body
	Aggregate
	Sort
	Filter
	FieldBoost
	InstanceBoost
	AggregateResponse
	SearchResponse
	Result
	AnalyseRequest
	AnalyseResponse
*/
package sajari_engine_query

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import sajari_engine "github.com/sajari/go-genproto/sajari/engine"
import sajari_engine1 "github.com/sajari/go-genproto/sajari/engine"
import sajari_engine2 "github.com/sajari/go-genproto/sajari/engine"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Enumeration of metric types.
type Aggregate_Metric_Type int32

const (
	// Average field value.
	Aggregate_Metric_AVG Aggregate_Metric_Type = 0
	// Minimum field value.
	Aggregate_Metric_MIN Aggregate_Metric_Type = 1
	// Maximum field value.
	Aggregate_Metric_MAX Aggregate_Metric_Type = 2
	// Sum of all field values.
	Aggregate_Metric_SUM Aggregate_Metric_Type = 3
)

var Aggregate_Metric_Type_name = map[int32]string{
	0: "AVG",
	1: "MIN",
	2: "MAX",
	3: "SUM",
}
var Aggregate_Metric_Type_value = map[string]int32{
	"AVG": 0,
	"MIN": 1,
	"MAX": 2,
	"SUM": 3,
}

func (x Aggregate_Metric_Type) String() string {
	return proto.EnumName(Aggregate_Metric_Type_name, int32(x))
}
func (Aggregate_Metric_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0, 0} }

// Order is an enumeration that defines orderings for sorting.
type Sort_Order int32

const (
	// Ascending: from least to greatest, for non-numeric
	// fields this means alphabetical order.
	Sort_ASC Sort_Order = 0
	// Descending: from greatest to least, for non-numeric
	// fields this means reverse-alphabetical order.
	Sort_DESC Sort_Order = 1
)

var Sort_Order_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var Sort_Order_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x Sort_Order) String() string {
	return proto.EnumName(Sort_Order_name, int32(x))
}
func (Sort_Order) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

// Operator is an enumeration of operators.
type Filter_Field_Operator int32

const (
	// Equal value.  For STRING fields this is case insensitive.
	Filter_Field_EQUAL_TO Filter_Field_Operator = 0
	// Not equal value.  For STRING fields this is case insensitive.
	Filter_Field_NOT_EQUAL_TO             Filter_Field_Operator = 1
	Filter_Field_GREATER_THAN             Filter_Field_Operator = 2
	Filter_Field_GREATER_THAN_OR_EQUAL_TO Filter_Field_Operator = 3
	Filter_Field_LESS_THAN                Filter_Field_Operator = 4
	Filter_Field_LESS_THAN_OR_EQUAL_TO    Filter_Field_Operator = 5
	// For STRING fields this is case insensitive.
	Filter_Field_CONTAINS Filter_Field_Operator = 6
	// For STRING fields this is case insensitive.
	Filter_Field_DOES_NOT_CONTAIN Filter_Field_Operator = 7
	// For STRING fields this is case insensitive.
	Filter_Field_HAS_SUFFIX Filter_Field_Operator = 8
	// For STRING fields this is case insensitive.
	Filter_Field_HAS_PREFIX Filter_Field_Operator = 9
)

var Filter_Field_Operator_name = map[int32]string{
	0: "EQUAL_TO",
	1: "NOT_EQUAL_TO",
	2: "GREATER_THAN",
	3: "GREATER_THAN_OR_EQUAL_TO",
	4: "LESS_THAN",
	5: "LESS_THAN_OR_EQUAL_TO",
	6: "CONTAINS",
	7: "DOES_NOT_CONTAIN",
	8: "HAS_SUFFIX",
	9: "HAS_PREFIX",
}
var Filter_Field_Operator_value = map[string]int32{
	"EQUAL_TO":                 0,
	"NOT_EQUAL_TO":             1,
	"GREATER_THAN":             2,
	"GREATER_THAN_OR_EQUAL_TO": 3,
	"LESS_THAN":                4,
	"LESS_THAN_OR_EQUAL_TO":    5,
	"CONTAINS":                 6,
	"DOES_NOT_CONTAIN":         7,
	"HAS_SUFFIX":               8,
	"HAS_PREFIX":               9,
}

func (x Filter_Field_Operator) String() string {
	return proto.EnumName(Filter_Field_Operator_name, int32(x))
}
func (Filter_Field_Operator) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0, 0} }

// Region is an enumeration that defines regions for geo-boosting.
type Filter_Geo_Region int32

const (
	// Inside is used to configure a geo filter to be
	// satisfied on all points within the radius.
	Filter_Geo_INSIDE Filter_Geo_Region = 0
	// Outside is used to configure a geo filter to be
	// satisfied to all points outside the radius.
	Filter_Geo_OUTSIDE Filter_Geo_Region = 1
)

var Filter_Geo_Region_name = map[int32]string{
	0: "INSIDE",
	1: "OUTSIDE",
}
var Filter_Geo_Region_value = map[string]int32{
	"INSIDE":  0,
	"OUTSIDE": 1,
}

func (x Filter_Geo_Region) String() string {
	return proto.EnumName(Filter_Geo_Region_name, int32(x))
}
func (Filter_Geo_Region) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1, 0} }

// Operator is an enumeration of combination operators.
type Filter_Combinator_Operator int32

const (
	// All of the filters must be satisfied.
	Filter_Combinator_ALL Filter_Combinator_Operator = 0
	// Any of the filters must be satisfied.
	Filter_Combinator_ANY Filter_Combinator_Operator = 1
	// One of the filters (and only one) must be satisfied.
	Filter_Combinator_ONE Filter_Combinator_Operator = 2
	// None of the filters must be satisfied.
	Filter_Combinator_NONE Filter_Combinator_Operator = 3
)

var Filter_Combinator_Operator_name = map[int32]string{
	0: "ALL",
	1: "ANY",
	2: "ONE",
	3: "NONE",
}
var Filter_Combinator_Operator_value = map[string]int32{
	"ALL":  0,
	"ANY":  1,
	"ONE":  2,
	"NONE": 3,
}

func (x Filter_Combinator_Operator) String() string {
	return proto.EnumName(Filter_Combinator_Operator_name, int32(x))
}
func (Filter_Combinator_Operator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{8, 2, 0}
}

// SearchRequest encompasses all the parameters necessary to query a search index.  Search requests
// allow callers to select documents from a collection and return them in a score-based
// ordering.
//
// Documents in the search index can be queried/scored using a combination of:
// 1. Field values (key-value pairs set by the user).  See Filter, FieldBoost, Sort.
// 2. Terms (extracted from the body of the document, or from string-based indexed fields).
//    See Body, Terms, InstanceBoost.
//
// Quering a search index follows three main steps:
// 1. Selecting potentially suitable documents to include in a result set.
// 2. Ranking and sorting the documents based on configurable scoring and/or sorting rules.
// 3. Computing aggregate statistical information from the result set.
type SearchRequest struct {
	// Body is a list of weighted free text.
	Body []*Body `protobuf:"bytes,1,rep,name=body" json:"body,omitempty"`
	// Terms is a list of weighted terms, where terms represent tokenised sequences of text.
	Terms []*Term `protobuf:"bytes,2,rep,name=terms" json:"terms,omitempty"`
	// Filter is rule which is checked against a document's meta values.
	//
	// Only documents that match the filter will be included in the result.
	Filter *Filter `protobuf:"bytes,3,opt,name=filter" json:"filter,omitempty"`
	// FieldBoosts are a list of rules checked against a document's field values.
	//
	// Field boosting allows callers to boost documents which have field values that
	// match a rule.
	FieldBoosts []*FieldBoost `protobuf:"bytes,4,rep,name=field_boosts,json=fieldBoosts" json:"field_boosts,omitempty"`
	// InstanceBoosts are a list of rules checked against a document's term instances.
	//
	// Instance boosting allows callers to boost documents which have terms that match
	// a rule.
	InstanceBoosts []*InstanceBoost `protobuf:"bytes,5,rep,name=instance_boosts,json=instanceBoosts" json:"instance_boosts,omitempty"`
	// Page number of results to return.
	Page int32 `protobuf:"varint,6,opt,name=page" json:"page,omitempty"`
	// Number of results to return per page.
	ResultsPerPage int32 `protobuf:"varint,7,opt,name=results_per_page,json=resultsPerPage" json:"results_per_page,omitempty"`
	// Fields to be returned for each result in the results. If empty then all fields are returned.
	Fields []string `protobuf:"bytes,8,rep,name=fields" json:"fields,omitempty"`
	// Sort ordering applied to results. Multiple sorts can be applied sequentially. If set, this
	// overrides the default score ordering of results.
	Sort []*Sort `protobuf:"bytes,9,rep,name=sort" json:"sort,omitempty"`
	// A set of Aggregates to be run on the result set.
	Aggregates map[string]*Aggregate `protobuf:"bytes,10,rep,name=aggregates" json:"aggregates,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Transforms to be applied to the request before it is run.
	Transforms []*Transform `protobuf:"bytes,11,rep,name=transforms" json:"transforms,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SearchRequest) GetBody() []*Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *SearchRequest) GetTerms() []*Term {
	if m != nil {
		return m.Terms
	}
	return nil
}

func (m *SearchRequest) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *SearchRequest) GetFieldBoosts() []*FieldBoost {
	if m != nil {
		return m.FieldBoosts
	}
	return nil
}

func (m *SearchRequest) GetInstanceBoosts() []*InstanceBoost {
	if m != nil {
		return m.InstanceBoosts
	}
	return nil
}

func (m *SearchRequest) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *SearchRequest) GetResultsPerPage() int32 {
	if m != nil {
		return m.ResultsPerPage
	}
	return 0
}

func (m *SearchRequest) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SearchRequest) GetSort() []*Sort {
	if m != nil {
		return m.Sort
	}
	return nil
}

func (m *SearchRequest) GetAggregates() map[string]*Aggregate {
	if m != nil {
		return m.Aggregates
	}
	return nil
}

func (m *SearchRequest) GetTransforms() []*Transform {
	if m != nil {
		return m.Transforms
	}
	return nil
}

// Transform is a transformation of the search request to be applied before
// the search is run. Transforms are typically used to extract additional
// features or to augment the input query itself.
type Transform struct {
	Identifier string `protobuf:"bytes,1,opt,name=identifier" json:"identifier,omitempty"`
}

func (m *Transform) Reset()                    { *m = Transform{} }
func (m *Transform) String() string            { return proto.CompactTextString(m) }
func (*Transform) ProtoMessage()               {}
func (*Transform) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Transform) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

// Term represents a tokenized piece of text (i.e. a single word, or number) and is the lowest level
// of index-based query input that can be specified.
type Term struct {
	// Term string value
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	// Field that the term originated from.
	Field string `protobuf:"bytes,2,opt,name=field" json:"field,omitempty"`
	// Number of positive interactions (uint16) this Term instance has been involved with.
	Pos uint32 `protobuf:"varint,3,opt,name=pos" json:"pos,omitempty"`
	// Number of negative interactions (uint16) this Term instance has been involved with.
	Neg uint32 `protobuf:"varint,4,opt,name=neg" json:"neg,omitempty"`
	// Significance of the term (uint16).
	Weight float64 `protobuf:"fixed64,5,opt,name=weight" json:"weight,omitempty"`
	// Word offset (context) (uint16). This indicates the position of this term instance
	// relative to other terms in a body string
	WordOffset uint32 `protobuf:"varint,6,opt,name=word_offset,json=wordOffset" json:"word_offset,omitempty"`
	// Paragraph offset (context) (uint16). This indicates the paragraph position (a grouping
	// of term instances) for this term instance in a body string. Useful for larger bodies
	// of text
	ParaOffset uint32 `protobuf:"varint,7,opt,name=para_offset,json=paraOffset" json:"para_offset,omitempty"`
}

func (m *Term) Reset()                    { *m = Term{} }
func (m *Term) String() string            { return proto.CompactTextString(m) }
func (*Term) ProtoMessage()               {}
func (*Term) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Term) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Term) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Term) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *Term) GetNeg() uint32 {
	if m != nil {
		return m.Neg
	}
	return 0
}

func (m *Term) GetWeight() float64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Term) GetWordOffset() uint32 {
	if m != nil {
		return m.WordOffset
	}
	return 0
}

func (m *Term) GetParaOffset() uint32 {
	if m != nil {
		return m.ParaOffset
	}
	return 0
}

// EvaluateRequest contains all parameters necessary to make an Evaluate call.
type EvaluateRequest struct {
	// Search request to run.
	SearchRequest *SearchRequest `protobuf:"bytes,1,opt,name=search_request,json=searchRequest" json:"search_request,omitempty"`
	// Document to search against.
	Document map[string][]byte `protobuf:"bytes,2,rep,name=document" json:"document,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EvaluateRequest) Reset()                    { *m = EvaluateRequest{} }
func (m *EvaluateRequest) String() string            { return proto.CompactTextString(m) }
func (*EvaluateRequest) ProtoMessage()               {}
func (*EvaluateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EvaluateRequest) GetSearchRequest() *SearchRequest {
	if m != nil {
		return m.SearchRequest
	}
	return nil
}

func (m *EvaluateRequest) GetDocument() map[string][]byte {
	if m != nil {
		return m.Document
	}
	return nil
}

type SubstituteRequest struct {
	// Request is used as a template
	SearchRequest *SearchRequest `protobuf:"bytes,1,opt,name=search_request,json=searchRequest" json:"search_request,omitempty"`
	// Document is the document to be substituted in the request.
	Document map[string][]byte `protobuf:"bytes,2,rep,name=document" json:"document,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SubstituteRequest) Reset()                    { *m = SubstituteRequest{} }
func (m *SubstituteRequest) String() string            { return proto.CompactTextString(m) }
func (*SubstituteRequest) ProtoMessage()               {}
func (*SubstituteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SubstituteRequest) GetSearchRequest() *SearchRequest {
	if m != nil {
		return m.SearchRequest
	}
	return nil
}

func (m *SubstituteRequest) GetDocument() map[string][]byte {
	if m != nil {
		return m.Document
	}
	return nil
}

// Body is a weighted free text query.
type Body struct {
	// Text (free text).
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
	// Weight (importance) to apply to this text.
	// This value must be 0 <= weight <= 1 but must be set. A value of zero means
	// the text has no value.
	Weight float64 `protobuf:"fixed64,2,opt,name=weight" json:"weight,omitempty"`
}

func (m *Body) Reset()                    { *m = Body{} }
func (m *Body) String() string            { return proto.CompactTextString(m) }
func (*Body) ProtoMessage()               {}
func (*Body) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Body) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Body) GetWeight() float64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// Aggregate is a statistical query run on the result set of a search.
type Aggregate struct {
	// Types that are valid to be assigned to Aggregate:
	//	*Aggregate_Metric_
	//	*Aggregate_Count_
	//	*Aggregate_Bucket_
	Aggregate isAggregate_Aggregate `protobuf_oneof:"aggregate"`
}

func (m *Aggregate) Reset()                    { *m = Aggregate{} }
func (m *Aggregate) String() string            { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()               {}
func (*Aggregate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isAggregate_Aggregate interface {
	isAggregate_Aggregate()
}

type Aggregate_Metric_ struct {
	Metric *Aggregate_Metric `protobuf:"bytes,1,opt,name=metric,oneof"`
}
type Aggregate_Count_ struct {
	Count *Aggregate_Count `protobuf:"bytes,2,opt,name=count,oneof"`
}
type Aggregate_Bucket_ struct {
	Bucket *Aggregate_Bucket `protobuf:"bytes,3,opt,name=bucket,oneof"`
}

func (*Aggregate_Metric_) isAggregate_Aggregate() {}
func (*Aggregate_Count_) isAggregate_Aggregate()  {}
func (*Aggregate_Bucket_) isAggregate_Aggregate() {}

func (m *Aggregate) GetAggregate() isAggregate_Aggregate {
	if m != nil {
		return m.Aggregate
	}
	return nil
}

func (m *Aggregate) GetMetric() *Aggregate_Metric {
	if x, ok := m.GetAggregate().(*Aggregate_Metric_); ok {
		return x.Metric
	}
	return nil
}

func (m *Aggregate) GetCount() *Aggregate_Count {
	if x, ok := m.GetAggregate().(*Aggregate_Count_); ok {
		return x.Count
	}
	return nil
}

func (m *Aggregate) GetBucket() *Aggregate_Bucket {
	if x, ok := m.GetAggregate().(*Aggregate_Bucket_); ok {
		return x.Bucket
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Aggregate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Aggregate_OneofMarshaler, _Aggregate_OneofUnmarshaler, _Aggregate_OneofSizer, []interface{}{
		(*Aggregate_Metric_)(nil),
		(*Aggregate_Count_)(nil),
		(*Aggregate_Bucket_)(nil),
	}
}

func _Aggregate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Aggregate)
	// aggregate
	switch x := m.Aggregate.(type) {
	case *Aggregate_Metric_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metric); err != nil {
			return err
		}
	case *Aggregate_Count_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Count); err != nil {
			return err
		}
	case *Aggregate_Bucket_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bucket); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Aggregate.Aggregate has unexpected type %T", x)
	}
	return nil
}

func _Aggregate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Aggregate)
	switch tag {
	case 1: // aggregate.metric
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Aggregate_Metric)
		err := b.DecodeMessage(msg)
		m.Aggregate = &Aggregate_Metric_{msg}
		return true, err
	case 2: // aggregate.count
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Aggregate_Count)
		err := b.DecodeMessage(msg)
		m.Aggregate = &Aggregate_Count_{msg}
		return true, err
	case 3: // aggregate.bucket
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Aggregate_Bucket)
		err := b.DecodeMessage(msg)
		m.Aggregate = &Aggregate_Bucket_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Aggregate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Aggregate)
	// aggregate
	switch x := m.Aggregate.(type) {
	case *Aggregate_Metric_:
		s := proto.Size(x.Metric)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Aggregate_Count_:
		s := proto.Size(x.Count)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Aggregate_Bucket_:
		s := proto.Size(x.Bucket)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metric calculates numerical information from a field.
type Aggregate_Metric struct {
	// Name of the field to run numerical metrics.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// The type of metric to apply.
	Type Aggregate_Metric_Type `protobuf:"varint,2,opt,name=type,enum=sajari.engine.query.Aggregate_Metric_Type" json:"type,omitempty"`
}

func (m *Aggregate_Metric) Reset()                    { *m = Aggregate_Metric{} }
func (m *Aggregate_Metric) String() string            { return proto.CompactTextString(m) }
func (*Aggregate_Metric) ProtoMessage()               {}
func (*Aggregate_Metric) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *Aggregate_Metric) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Aggregate_Metric) GetType() Aggregate_Metric_Type {
	if m != nil {
		return m.Type
	}
	return Aggregate_Metric_AVG
}

// Count records the number of unique values for a field.
type Aggregate_Count struct {
	// Name of the field to count values from.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
}

func (m *Aggregate_Count) Reset()                    { *m = Aggregate_Count{} }
func (m *Aggregate_Count) String() string            { return proto.CompactTextString(m) }
func (*Aggregate_Count) ProtoMessage()               {}
func (*Aggregate_Count) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 1} }

func (m *Aggregate_Count) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

// Bucket groups documents using filters, Documents which satisfy the filter
// will be included in the bucket.
type Aggregate_Bucket struct {
	// List of buckets.
	Buckets []*Aggregate_Bucket_Bucket `protobuf:"bytes,1,rep,name=buckets" json:"buckets,omitempty"`
}

func (m *Aggregate_Bucket) Reset()                    { *m = Aggregate_Bucket{} }
func (m *Aggregate_Bucket) String() string            { return proto.CompactTextString(m) }
func (*Aggregate_Bucket) ProtoMessage()               {}
func (*Aggregate_Bucket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 2} }

func (m *Aggregate_Bucket) GetBuckets() []*Aggregate_Bucket_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// Bucket represents documents which satisfy a Filter.
type Aggregate_Bucket_Bucket struct {
	// Name of the bucket.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Filter satisfied by documents in the bucket.
	Filter *Filter `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
}

func (m *Aggregate_Bucket_Bucket) Reset()                    { *m = Aggregate_Bucket_Bucket{} }
func (m *Aggregate_Bucket_Bucket) String() string            { return proto.CompactTextString(m) }
func (*Aggregate_Bucket_Bucket) ProtoMessage()               {}
func (*Aggregate_Bucket_Bucket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 2, 0} }

func (m *Aggregate_Bucket_Bucket) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Aggregate_Bucket_Bucket) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// Sort defines the ordering of result documents using field values.
type Sort struct {
	// Field to take values from.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// Sorting order.
	Order Sort_Order `protobuf:"varint,2,opt,name=order,enum=sajari.engine.query.Sort_Order" json:"order,omitempty"`
}

func (m *Sort) Reset()                    { *m = Sort{} }
func (m *Sort) String() string            { return proto.CompactTextString(m) }
func (*Sort) ProtoMessage()               {}
func (*Sort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Sort) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Sort) GetOrder() Sort_Order {
	if m != nil {
		return m.Order
	}
	return Sort_ASC
}

// Filter describes a set of conditions to match values in document fields.
// Filters can be nested and combined using Combinators.
type Filter struct {
	// Types that are valid to be assigned to Filter:
	//	*Filter_Combinator_
	//	*Filter_Field_
	//	*Filter_Geo_
	Filter isFilter_Filter `protobuf_oneof:"filter"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isFilter_Filter interface {
	isFilter_Filter()
}

type Filter_Combinator_ struct {
	Combinator *Filter_Combinator `protobuf:"bytes,1,opt,name=combinator,oneof"`
}
type Filter_Field_ struct {
	Field *Filter_Field `protobuf:"bytes,2,opt,name=field,oneof"`
}
type Filter_Geo_ struct {
	Geo *Filter_Geo `protobuf:"bytes,3,opt,name=geo,oneof"`
}

func (*Filter_Combinator_) isFilter_Filter() {}
func (*Filter_Field_) isFilter_Filter()      {}
func (*Filter_Geo_) isFilter_Filter()        {}

func (m *Filter) GetFilter() isFilter_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *Filter) GetCombinator() *Filter_Combinator {
	if x, ok := m.GetFilter().(*Filter_Combinator_); ok {
		return x.Combinator
	}
	return nil
}

func (m *Filter) GetField() *Filter_Field {
	if x, ok := m.GetFilter().(*Filter_Field_); ok {
		return x.Field
	}
	return nil
}

func (m *Filter) GetGeo() *Filter_Geo {
	if x, ok := m.GetFilter().(*Filter_Geo_); ok {
		return x.Geo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Filter) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Filter_OneofMarshaler, _Filter_OneofUnmarshaler, _Filter_OneofSizer, []interface{}{
		(*Filter_Combinator_)(nil),
		(*Filter_Field_)(nil),
		(*Filter_Geo_)(nil),
	}
}

func _Filter_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Filter)
	// filter
	switch x := m.Filter.(type) {
	case *Filter_Combinator_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Combinator); err != nil {
			return err
		}
	case *Filter_Field_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Field); err != nil {
			return err
		}
	case *Filter_Geo_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Geo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Filter.Filter has unexpected type %T", x)
	}
	return nil
}

func _Filter_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Filter)
	switch tag {
	case 1: // filter.combinator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Filter_Combinator)
		err := b.DecodeMessage(msg)
		m.Filter = &Filter_Combinator_{msg}
		return true, err
	case 2: // filter.field
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Filter_Field)
		err := b.DecodeMessage(msg)
		m.Filter = &Filter_Field_{msg}
		return true, err
	case 3: // filter.geo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Filter_Geo)
		err := b.DecodeMessage(msg)
		m.Filter = &Filter_Geo_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Filter_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Filter)
	// filter
	switch x := m.Filter.(type) {
	case *Filter_Combinator_:
		s := proto.Size(x.Combinator)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filter_Field_:
		s := proto.Size(x.Field)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filter_Geo_:
		s := proto.Size(x.Geo)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Field is a filter which is applied to a document field.
type Filter_Field struct {
	// The comparison operator to use.
	Operator Filter_Field_Operator `protobuf:"varint,1,opt,name=operator,enum=sajari.engine.query.Filter_Field_Operator" json:"operator,omitempty"`
	// Field to take values from.
	Field string `protobuf:"bytes,2,opt,name=field" json:"field,omitempty"`
	// Value to match against.
	Value *sajari_engine.Value `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *Filter_Field) Reset()                    { *m = Filter_Field{} }
func (m *Filter_Field) String() string            { return proto.CompactTextString(m) }
func (*Filter_Field) ProtoMessage()               {}
func (*Filter_Field) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *Filter_Field) GetOperator() Filter_Field_Operator {
	if m != nil {
		return m.Operator
	}
	return Filter_Field_EQUAL_TO
}

func (m *Filter_Field) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Filter_Field) GetValue() *sajari_engine.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Geo is a geo-based filter for documents with lat/lng fields representing a location.
type Filter_Geo struct {
	// Field containing latitude (degrees).
	FieldLat string `protobuf:"bytes,1,opt,name=field_lat,json=fieldLat" json:"field_lat,omitempty"`
	// Field containing longitude (degrees).
	FieldLng string `protobuf:"bytes,2,opt,name=field_lng,json=fieldLng" json:"field_lng,omitempty"`
	// Target latitude (in degrees).
	Lat float64 `protobuf:"fixed64,3,opt,name=lat" json:"lat,omitempty"`
	// Target longitude (in degrees).
	Lng float64 `protobuf:"fixed64,4,opt,name=lng" json:"lng,omitempty"`
	// Radius (in km) of matching border (see region).
	Radius float64 `protobuf:"fixed64,5,opt,name=radius" json:"radius,omitempty"`
	// Region for matching points.
	Region Filter_Geo_Region `protobuf:"varint,6,opt,name=region,enum=sajari.engine.query.Filter_Geo_Region" json:"region,omitempty"`
}

func (m *Filter_Geo) Reset()                    { *m = Filter_Geo{} }
func (m *Filter_Geo) String() string            { return proto.CompactTextString(m) }
func (*Filter_Geo) ProtoMessage()               {}
func (*Filter_Geo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1} }

func (m *Filter_Geo) GetFieldLat() string {
	if m != nil {
		return m.FieldLat
	}
	return ""
}

func (m *Filter_Geo) GetFieldLng() string {
	if m != nil {
		return m.FieldLng
	}
	return ""
}

func (m *Filter_Geo) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *Filter_Geo) GetLng() float64 {
	if m != nil {
		return m.Lng
	}
	return 0
}

func (m *Filter_Geo) GetRadius() float64 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *Filter_Geo) GetRegion() Filter_Geo_Region {
	if m != nil {
		return m.Region
	}
	return Filter_Geo_INSIDE
}

// Combinator is a filter which combines other filters.
type Filter_Combinator struct {
	// The operator used to combine filters.
	Operator Filter_Combinator_Operator `protobuf:"varint,1,opt,name=operator,enum=sajari.engine.query.Filter_Combinator_Operator" json:"operator,omitempty"`
	// The set of filters to combine using the specified Operator.
	Filters []*Filter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
}

func (m *Filter_Combinator) Reset()                    { *m = Filter_Combinator{} }
func (m *Filter_Combinator) String() string            { return proto.CompactTextString(m) }
func (*Filter_Combinator) ProtoMessage()               {}
func (*Filter_Combinator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 2} }

func (m *Filter_Combinator) GetOperator() Filter_Combinator_Operator {
	if m != nil {
		return m.Operator
	}
	return Filter_Combinator_ALL
}

func (m *Filter_Combinator) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// FieldBoost is used to influence the score of a document based on its field values.
//
// The effect of a FieldBoost is the value that it contributes to the overall score.
// All boost effects are between 0 and 1 inclusive.
//
// Wrap a FieldBoost in an AdditiveFieldBoost to make it contribute to a
// proportion of the overal score instead of multiplying the existing score.
type FieldBoost struct {
	// Types that are valid to be assigned to FieldBoost:
	//	*FieldBoost_Additive_
	//	*FieldBoost_Filter_
	//	*FieldBoost_Interval_
	//	*FieldBoost_Distance_
	//	*FieldBoost_Element_
	//	*FieldBoost_Text_
	FieldBoost isFieldBoost_FieldBoost `protobuf_oneof:"field_boost"`
}

func (m *FieldBoost) Reset()                    { *m = FieldBoost{} }
func (m *FieldBoost) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost) ProtoMessage()               {}
func (*FieldBoost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isFieldBoost_FieldBoost interface {
	isFieldBoost_FieldBoost()
}

type FieldBoost_Additive_ struct {
	Additive *FieldBoost_Additive `protobuf:"bytes,1,opt,name=additive,oneof"`
}
type FieldBoost_Filter_ struct {
	Filter *FieldBoost_Filter `protobuf:"bytes,2,opt,name=filter,oneof"`
}
type FieldBoost_Interval_ struct {
	Interval *FieldBoost_Interval `protobuf:"bytes,3,opt,name=interval,oneof"`
}
type FieldBoost_Distance_ struct {
	Distance *FieldBoost_Distance `protobuf:"bytes,4,opt,name=distance,oneof"`
}
type FieldBoost_Element_ struct {
	Element *FieldBoost_Element `protobuf:"bytes,5,opt,name=element,oneof"`
}
type FieldBoost_Text_ struct {
	Text *FieldBoost_Text `protobuf:"bytes,6,opt,name=text,oneof"`
}

func (*FieldBoost_Additive_) isFieldBoost_FieldBoost() {}
func (*FieldBoost_Filter_) isFieldBoost_FieldBoost()   {}
func (*FieldBoost_Interval_) isFieldBoost_FieldBoost() {}
func (*FieldBoost_Distance_) isFieldBoost_FieldBoost() {}
func (*FieldBoost_Element_) isFieldBoost_FieldBoost()  {}
func (*FieldBoost_Text_) isFieldBoost_FieldBoost()     {}

func (m *FieldBoost) GetFieldBoost() isFieldBoost_FieldBoost {
	if m != nil {
		return m.FieldBoost
	}
	return nil
}

func (m *FieldBoost) GetAdditive() *FieldBoost_Additive {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Additive_); ok {
		return x.Additive
	}
	return nil
}

func (m *FieldBoost) GetFilter() *FieldBoost_Filter {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Filter_); ok {
		return x.Filter
	}
	return nil
}

func (m *FieldBoost) GetInterval() *FieldBoost_Interval {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Interval_); ok {
		return x.Interval
	}
	return nil
}

func (m *FieldBoost) GetDistance() *FieldBoost_Distance {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Distance_); ok {
		return x.Distance
	}
	return nil
}

func (m *FieldBoost) GetElement() *FieldBoost_Element {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Element_); ok {
		return x.Element
	}
	return nil
}

func (m *FieldBoost) GetText() *FieldBoost_Text {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Text_); ok {
		return x.Text
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FieldBoost) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FieldBoost_OneofMarshaler, _FieldBoost_OneofUnmarshaler, _FieldBoost_OneofSizer, []interface{}{
		(*FieldBoost_Additive_)(nil),
		(*FieldBoost_Filter_)(nil),
		(*FieldBoost_Interval_)(nil),
		(*FieldBoost_Distance_)(nil),
		(*FieldBoost_Element_)(nil),
		(*FieldBoost_Text_)(nil),
	}
}

func _FieldBoost_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FieldBoost)
	// field_boost
	switch x := m.FieldBoost.(type) {
	case *FieldBoost_Additive_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Additive); err != nil {
			return err
		}
	case *FieldBoost_Filter_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Filter); err != nil {
			return err
		}
	case *FieldBoost_Interval_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Interval); err != nil {
			return err
		}
	case *FieldBoost_Distance_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Distance); err != nil {
			return err
		}
	case *FieldBoost_Element_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Element); err != nil {
			return err
		}
	case *FieldBoost_Text_:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Text); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FieldBoost.FieldBoost has unexpected type %T", x)
	}
	return nil
}

func _FieldBoost_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FieldBoost)
	switch tag {
	case 1: // field_boost.additive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Additive)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Additive_{msg}
		return true, err
	case 2: // field_boost.filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Filter)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Filter_{msg}
		return true, err
	case 3: // field_boost.interval
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Interval)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Interval_{msg}
		return true, err
	case 4: // field_boost.distance
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Distance)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Distance_{msg}
		return true, err
	case 5: // field_boost.element
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Element)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Element_{msg}
		return true, err
	case 6: // field_boost.text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Text)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Text_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FieldBoost_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FieldBoost)
	// field_boost
	switch x := m.FieldBoost.(type) {
	case *FieldBoost_Additive_:
		s := proto.Size(x.Additive)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldBoost_Filter_:
		s := proto.Size(x.Filter)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldBoost_Interval_:
		s := proto.Size(x.Interval)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldBoost_Distance_:
		s := proto.Size(x.Distance)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldBoost_Element_:
		s := proto.Size(x.Element)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldBoost_Text_:
		s := proto.Size(x.Text)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Additive is a FieldBoost wrapper which makes the boost value represent
// a proportion of the overall score instead of scaling the existing
// score.
type FieldBoost_Additive struct {
	// FieldBoost to make additive.
	FieldBoost *FieldBoost `protobuf:"bytes,1,opt,name=field_boost,json=fieldBoost" json:"field_boost,omitempty"`
	// Amount this boost will contribute to the overall score of the document.
	//
	// Must be between 0 and 1.
	Value float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *FieldBoost_Additive) Reset()                    { *m = FieldBoost_Additive{} }
func (m *FieldBoost_Additive) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Additive) ProtoMessage()               {}
func (*FieldBoost_Additive) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *FieldBoost_Additive) GetFieldBoost() *FieldBoost {
	if m != nil {
		return m.FieldBoost
	}
	return nil
}

func (m *FieldBoost_Additive) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Filter is a boost applied to documents which satisfy the filter.
type FieldBoost_Filter struct {
	// Filter which must be satisfied by document.
	Filter *Filter `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
	// Boost value to apply to matching documents. Must be >= 0.
	//
	// Value == 0     Matching documents get 0 for this boost, everything else gets 1.
	// Value == 1     Matching documents get 1 for this boost, everything else gets 0.
	// 0 < Value < 1  Matching documents get Value for this boost (and are penalised).
	// Value > 1      Matching documents get 1 for this boost, everything else gets 1 / Value.
	Value float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *FieldBoost_Filter) Reset()                    { *m = FieldBoost_Filter{} }
func (m *FieldBoost_Filter) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Filter) ProtoMessage()               {}
func (*FieldBoost_Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 1} }

func (m *FieldBoost_Filter) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *FieldBoost_Filter) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Interval is a distance-based boosting for numeric fields.
//
// It is comprised of a series of points to represent
// any linear distribution across a numerical range.
type FieldBoost_Interval struct {
	// Numerical field to apply the boost.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// Points which define intervals boundaries (must be at least 2).
	// Values between internal points are determined linearly.
	Points []*FieldBoost_Interval_Point `protobuf:"bytes,2,rep,name=points" json:"points,omitempty"`
}

func (m *FieldBoost_Interval) Reset()                    { *m = FieldBoost_Interval{} }
func (m *FieldBoost_Interval) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Interval) ProtoMessage()               {}
func (*FieldBoost_Interval) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 2} }

func (m *FieldBoost_Interval) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *FieldBoost_Interval) GetPoints() []*FieldBoost_Interval_Point {
	if m != nil {
		return m.Points
	}
	return nil
}

// Point is a pair (point, value) which defines the boost value
// at a particiular point.
type FieldBoost_Interval_Point struct {
	// The point to mark the beginning/end of an interval.
	Point float64 `protobuf:"fixed64,1,opt,name=point" json:"point,omitempty"`
	// The amount to boost by at this Point.
	Value float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *FieldBoost_Interval_Point) Reset()                    { *m = FieldBoost_Interval_Point{} }
func (m *FieldBoost_Interval_Point) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Interval_Point) ProtoMessage()               {}
func (*FieldBoost_Interval_Point) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 2, 0} }

func (m *FieldBoost_Interval_Point) GetPoint() float64 {
	if m != nil {
		return m.Point
	}
	return 0
}

func (m *FieldBoost_Interval_Point) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Distance is a distance-based boosting for numeric fields.
//
// It defines a reference point within a interval defined by a min and max value.
// The boost is then applied to values which fall in the min-max interval and is
// evaluated based on the distance to the reference point.
//
// Boost effect: between 0 and 1.
type FieldBoost_Distance struct {
	// Minimum distance from the ref point.
	Min float64 `protobuf:"fixed64,1,opt,name=min" json:"min,omitempty"`
	// Maximum distance from the ref point.
	Max float64 `protobuf:"fixed64,2,opt,name=max" json:"max,omitempty"`
	// Reference value to compare against.
	Ref float64 `protobuf:"fixed64,3,opt,name=ref" json:"ref,omitempty"`
	// Numerical field to apply the boost.
	Field string `protobuf:"bytes,4,opt,name=field" json:"field,omitempty"`
	// Value to apply to points inside the min-max range.
	Value float64 `protobuf:"fixed64,5,opt,name=value" json:"value,omitempty"`
}

func (m *FieldBoost_Distance) Reset()                    { *m = FieldBoost_Distance{} }
func (m *FieldBoost_Distance) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Distance) ProtoMessage()               {}
func (*FieldBoost_Distance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 3} }

func (m *FieldBoost_Distance) GetMin() float64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *FieldBoost_Distance) GetMax() float64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *FieldBoost_Distance) GetRef() float64 {
	if m != nil {
		return m.Ref
	}
	return 0
}

func (m *FieldBoost_Distance) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *FieldBoost_Distance) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Element is an element-based boost for repeated fields.
//
// The boost is evaluated as a portion of a list of values which appear
// in the document field.
//
// Boost effect: between 0 and 1.
type FieldBoost_Element struct {
	// Field containing stringArray.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// List of elements to compare against the field values.
	Elts []string `protobuf:"bytes,3,rep,name=elts" json:"elts,omitempty"`
}

func (m *FieldBoost_Element) Reset()                    { *m = FieldBoost_Element{} }
func (m *FieldBoost_Element) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Element) ProtoMessage()               {}
func (*FieldBoost_Element) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 4} }

func (m *FieldBoost_Element) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *FieldBoost_Element) GetElts() []string {
	if m != nil {
		return m.Elts
	}
	return nil
}

// Text represents a text-based boosting for string fields.
//
// Compares text (using a bag of words model) and applies a boost based on the
// number of intersecting words.
//
// Boost effect: between 0 and 1.
type FieldBoost_Text struct {
	// Field containing string data.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// Text to compare against the field value.
	Text string `protobuf:"bytes,3,opt,name=text" json:"text,omitempty"`
}

func (m *FieldBoost_Text) Reset()                    { *m = FieldBoost_Text{} }
func (m *FieldBoost_Text) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Text) ProtoMessage()               {}
func (*FieldBoost_Text) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 5} }

func (m *FieldBoost_Text) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *FieldBoost_Text) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// InstanceBoost represents a boosting which is a applied to instances of terms
// in the reverse index.  This type of boost effectively dynamically ranks
// documents for a given term
type InstanceBoost struct {
	// Types that are valid to be assigned to InstanceBoost:
	//	*InstanceBoost_Field_
	//	*InstanceBoost_Score_
	InstanceBoost isInstanceBoost_InstanceBoost `protobuf_oneof:"instance_boost"`
}

func (m *InstanceBoost) Reset()                    { *m = InstanceBoost{} }
func (m *InstanceBoost) String() string            { return proto.CompactTextString(m) }
func (*InstanceBoost) ProtoMessage()               {}
func (*InstanceBoost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isInstanceBoost_InstanceBoost interface {
	isInstanceBoost_InstanceBoost()
}

type InstanceBoost_Field_ struct {
	Field *InstanceBoost_Field `protobuf:"bytes,1,opt,name=field,oneof"`
}
type InstanceBoost_Score_ struct {
	Score *InstanceBoost_Score `protobuf:"bytes,2,opt,name=score,oneof"`
}

func (*InstanceBoost_Field_) isInstanceBoost_InstanceBoost() {}
func (*InstanceBoost_Score_) isInstanceBoost_InstanceBoost() {}

func (m *InstanceBoost) GetInstanceBoost() isInstanceBoost_InstanceBoost {
	if m != nil {
		return m.InstanceBoost
	}
	return nil
}

func (m *InstanceBoost) GetField() *InstanceBoost_Field {
	if x, ok := m.GetInstanceBoost().(*InstanceBoost_Field_); ok {
		return x.Field
	}
	return nil
}

func (m *InstanceBoost) GetScore() *InstanceBoost_Score {
	if x, ok := m.GetInstanceBoost().(*InstanceBoost_Score_); ok {
		return x.Score
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstanceBoost) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstanceBoost_OneofMarshaler, _InstanceBoost_OneofUnmarshaler, _InstanceBoost_OneofSizer, []interface{}{
		(*InstanceBoost_Field_)(nil),
		(*InstanceBoost_Score_)(nil),
	}
}

func _InstanceBoost_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstanceBoost)
	// instance_boost
	switch x := m.InstanceBoost.(type) {
	case *InstanceBoost_Field_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Field); err != nil {
			return err
		}
	case *InstanceBoost_Score_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Score); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstanceBoost.InstanceBoost has unexpected type %T", x)
	}
	return nil
}

func _InstanceBoost_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstanceBoost)
	switch tag {
	case 1: // instance_boost.field
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InstanceBoost_Field)
		err := b.DecodeMessage(msg)
		m.InstanceBoost = &InstanceBoost_Field_{msg}
		return true, err
	case 2: // instance_boost.score
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InstanceBoost_Score)
		err := b.DecodeMessage(msg)
		m.InstanceBoost = &InstanceBoost_Score_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstanceBoost_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstanceBoost)
	// instance_boost
	switch x := m.InstanceBoost.(type) {
	case *InstanceBoost_Field_:
		s := proto.Size(x.Field)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstanceBoost_Score_:
		s := proto.Size(x.Score)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Field is an instance boost which is applied to term instances which originate
// from the given meta field.
type InstanceBoost_Field struct {
	// Field where the term instance was defined.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// Value to boost terms from this field. A value between 0 and 1 will decrease
	// the score, a value greater than 1 will increase the score.
	Value float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *InstanceBoost_Field) Reset()                    { *m = InstanceBoost_Field{} }
func (m *InstanceBoost_Field) String() string            { return proto.CompactTextString(m) }
func (*InstanceBoost_Field) ProtoMessage()               {}
func (*InstanceBoost_Field) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

func (m *InstanceBoost_Field) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *InstanceBoost_Field) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Score is an instance boost that boosts term instances based on their individual
// scores based on individual interactions.
type InstanceBoost_Score struct {
	// Threshold defines the maximum value to allow.  This is used to scale and cap
	// the computed score.
	Threshold float64 `protobuf:"fixed64,1,opt,name=threshold" json:"threshold,omitempty"`
	// MinCount is the minimum number of interactions required to enable scoring.
	MinCount uint32 `protobuf:"varint,2,opt,name=min_count,json=minCount" json:"min_count,omitempty"`
}

func (m *InstanceBoost_Score) Reset()                    { *m = InstanceBoost_Score{} }
func (m *InstanceBoost_Score) String() string            { return proto.CompactTextString(m) }
func (*InstanceBoost_Score) ProtoMessage()               {}
func (*InstanceBoost_Score) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 1} }

func (m *InstanceBoost_Score) GetThreshold() float64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *InstanceBoost_Score) GetMinCount() uint32 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

// AggregateResponse contains statistical information representing aggregation results
type AggregateResponse struct {
	// Types that are valid to be assigned to AggregateResponse:
	//	*AggregateResponse_Metric_
	//	*AggregateResponse_Count_
	//	*AggregateResponse_Buckets_
	AggregateResponse isAggregateResponse_AggregateResponse `protobuf_oneof:"aggregate_response"`
}

func (m *AggregateResponse) Reset()                    { *m = AggregateResponse{} }
func (m *AggregateResponse) String() string            { return proto.CompactTextString(m) }
func (*AggregateResponse) ProtoMessage()               {}
func (*AggregateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isAggregateResponse_AggregateResponse interface {
	isAggregateResponse_AggregateResponse()
}

type AggregateResponse_Metric_ struct {
	Metric *AggregateResponse_Metric `protobuf:"bytes,1,opt,name=metric,oneof"`
}
type AggregateResponse_Count_ struct {
	Count *AggregateResponse_Count `protobuf:"bytes,2,opt,name=count,oneof"`
}
type AggregateResponse_Buckets_ struct {
	Buckets *AggregateResponse_Buckets `protobuf:"bytes,3,opt,name=buckets,oneof"`
}

func (*AggregateResponse_Metric_) isAggregateResponse_AggregateResponse()  {}
func (*AggregateResponse_Count_) isAggregateResponse_AggregateResponse()   {}
func (*AggregateResponse_Buckets_) isAggregateResponse_AggregateResponse() {}

func (m *AggregateResponse) GetAggregateResponse() isAggregateResponse_AggregateResponse {
	if m != nil {
		return m.AggregateResponse
	}
	return nil
}

func (m *AggregateResponse) GetMetric() *AggregateResponse_Metric {
	if x, ok := m.GetAggregateResponse().(*AggregateResponse_Metric_); ok {
		return x.Metric
	}
	return nil
}

func (m *AggregateResponse) GetCount() *AggregateResponse_Count {
	if x, ok := m.GetAggregateResponse().(*AggregateResponse_Count_); ok {
		return x.Count
	}
	return nil
}

func (m *AggregateResponse) GetBuckets() *AggregateResponse_Buckets {
	if x, ok := m.GetAggregateResponse().(*AggregateResponse_Buckets_); ok {
		return x.Buckets
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AggregateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AggregateResponse_OneofMarshaler, _AggregateResponse_OneofUnmarshaler, _AggregateResponse_OneofSizer, []interface{}{
		(*AggregateResponse_Metric_)(nil),
		(*AggregateResponse_Count_)(nil),
		(*AggregateResponse_Buckets_)(nil),
	}
}

func _AggregateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AggregateResponse)
	// aggregate_response
	switch x := m.AggregateResponse.(type) {
	case *AggregateResponse_Metric_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metric); err != nil {
			return err
		}
	case *AggregateResponse_Count_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Count); err != nil {
			return err
		}
	case *AggregateResponse_Buckets_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Buckets); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AggregateResponse.AggregateResponse has unexpected type %T", x)
	}
	return nil
}

func _AggregateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AggregateResponse)
	switch tag {
	case 1: // aggregate_response.metric
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AggregateResponse_Metric)
		err := b.DecodeMessage(msg)
		m.AggregateResponse = &AggregateResponse_Metric_{msg}
		return true, err
	case 2: // aggregate_response.count
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AggregateResponse_Count)
		err := b.DecodeMessage(msg)
		m.AggregateResponse = &AggregateResponse_Count_{msg}
		return true, err
	case 3: // aggregate_response.buckets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AggregateResponse_Buckets)
		err := b.DecodeMessage(msg)
		m.AggregateResponse = &AggregateResponse_Buckets_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AggregateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AggregateResponse)
	// aggregate_response
	switch x := m.AggregateResponse.(type) {
	case *AggregateResponse_Metric_:
		s := proto.Size(x.Metric)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AggregateResponse_Count_:
		s := proto.Size(x.Count)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AggregateResponse_Buckets_:
		s := proto.Size(x.Buckets)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metric represents the metric type requested, represented by an Enumeration Type.
type AggregateResponse_Metric struct {
	Value float64 `protobuf:"fixed64,1,opt,name=value" json:"value,omitempty"`
}

func (m *AggregateResponse_Metric) Reset()                    { *m = AggregateResponse_Metric{} }
func (m *AggregateResponse_Metric) String() string            { return proto.CompactTextString(m) }
func (*AggregateResponse_Metric) ProtoMessage()               {}
func (*AggregateResponse_Metric) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

func (m *AggregateResponse_Metric) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Count contains the counts for the set of values returned
type AggregateResponse_Count struct {
	Counts map[string]int32 `protobuf:"bytes,1,rep,name=counts" json:"counts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *AggregateResponse_Count) Reset()                    { *m = AggregateResponse_Count{} }
func (m *AggregateResponse_Count) String() string            { return proto.CompactTextString(m) }
func (*AggregateResponse_Count) ProtoMessage()               {}
func (*AggregateResponse_Count) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 1} }

func (m *AggregateResponse_Count) GetCounts() map[string]int32 {
	if m != nil {
		return m.Counts
	}
	return nil
}

// Buckets is a full set of buckets computed in an aggregation.
type AggregateResponse_Buckets struct {
	Buckets map[string]*AggregateResponse_Buckets_Bucket `protobuf:"bytes,1,rep,name=buckets" json:"buckets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AggregateResponse_Buckets) Reset()                    { *m = AggregateResponse_Buckets{} }
func (m *AggregateResponse_Buckets) String() string            { return proto.CompactTextString(m) }
func (*AggregateResponse_Buckets) ProtoMessage()               {}
func (*AggregateResponse_Buckets) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 2} }

func (m *AggregateResponse_Buckets) GetBuckets() map[string]*AggregateResponse_Buckets_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// Bucket is the result of a bucket aggregate.
type AggregateResponse_Buckets_Bucket struct {
	// Name of bucket.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Number of documents in the bucket.
	Count int32 `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
}

func (m *AggregateResponse_Buckets_Bucket) Reset()         { *m = AggregateResponse_Buckets_Bucket{} }
func (m *AggregateResponse_Buckets_Bucket) String() string { return proto.CompactTextString(m) }
func (*AggregateResponse_Buckets_Bucket) ProtoMessage()    {}
func (*AggregateResponse_Buckets_Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 2, 0}
}

func (m *AggregateResponse_Buckets_Bucket) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AggregateResponse_Buckets_Bucket) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// SearchResponse contains all data in response to a search request.
type SearchResponse struct {
	// Number of reverse indexes read during the search request.
	Reads int64 `protobuf:"varint,1,opt,name=reads" json:"reads,omitempty"`
	// Total number of results.
	TotalResults int64 `protobuf:"varint,2,opt,name=total_results,json=totalResults" json:"total_results,omitempty"`
	// Time taken to perform query.
	Time string `protobuf:"bytes,3,opt,name=time" json:"time,omitempty"`
	// Aggregates returned by query.
	Aggregates map[string]*AggregateResponse `protobuf:"bytes,4,rep,name=aggregates" json:"aggregates,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Results returned by query.
	Results []*Result `protobuf:"bytes,5,rep,name=results" json:"results,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SearchResponse) GetReads() int64 {
	if m != nil {
		return m.Reads
	}
	return 0
}

func (m *SearchResponse) GetTotalResults() int64 {
	if m != nil {
		return m.TotalResults
	}
	return 0
}

func (m *SearchResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *SearchResponse) GetAggregates() map[string]*AggregateResponse {
	if m != nil {
		return m.Aggregates
	}
	return nil
}

func (m *SearchResponse) GetResults() []*Result {
	if m != nil {
		return m.Results
	}
	return nil
}

// Result is a document as represented in a search result.
type Result struct {
	// Meta data in field-value pairs.
	Values map[string]*sajari_engine.Value `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Score (normalised) attributed to this document by the raw_score and boosting components.
	Score float64 `protobuf:"fixed64,2,opt,name=score" json:"score,omitempty"`
	// Raw score attributed to this document by the query reverse index intersections.
	RawScore float64 `protobuf:"fixed64,3,opt,name=raw_score,json=rawScore" json:"raw_score,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Result) GetValues() map[string]*sajari_engine.Value {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *Result) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Result) GetRawScore() float64 {
	if m != nil {
		return m.RawScore
	}
	return 0
}

// AnalyseRequest applies a search request to a document.
type AnalyseRequest struct {
	// Request is a search request which should be applied against a document
	// in the store.
	SearchRequest *SearchRequest `protobuf:"bytes,1,opt,name=search_request,json=searchRequest" json:"search_request,omitempty"`
	// Key is a unique identifier corresponding to a document in the store.
	Keys []*sajari_engine2.Key `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
}

func (m *AnalyseRequest) Reset()                    { *m = AnalyseRequest{} }
func (m *AnalyseRequest) String() string            { return proto.CompactTextString(m) }
func (*AnalyseRequest) ProtoMessage()               {}
func (*AnalyseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AnalyseRequest) GetSearchRequest() *SearchRequest {
	if m != nil {
		return m.SearchRequest
	}
	return nil
}

func (m *AnalyseRequest) GetKeys() []*sajari_engine2.Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

// AnalyseResponse contains the analysis of the document against the query
// request.
type AnalyseResponse struct {
	// Terms is the list of intersecting terms between the document and the
	// search query request.
	Terms []*AnalyseResponse_Terms `protobuf:"bytes,1,rep,name=terms" json:"terms,omitempty"`
	// Status corresponding to each key in the request.
	Status []*sajari_engine1.Status `protobuf:"bytes,2,rep,name=status" json:"status,omitempty"`
}

func (m *AnalyseResponse) Reset()                    { *m = AnalyseResponse{} }
func (m *AnalyseResponse) String() string            { return proto.CompactTextString(m) }
func (*AnalyseResponse) ProtoMessage()               {}
func (*AnalyseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *AnalyseResponse) GetTerms() []*AnalyseResponse_Terms {
	if m != nil {
		return m.Terms
	}
	return nil
}

func (m *AnalyseResponse) GetStatus() []*sajari_engine1.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Terms is a list of terms which overlap for a particular document.
type AnalyseResponse_Terms struct {
	Terms []string `protobuf:"bytes,1,rep,name=terms" json:"terms,omitempty"`
}

func (m *AnalyseResponse_Terms) Reset()                    { *m = AnalyseResponse_Terms{} }
func (m *AnalyseResponse_Terms) String() string            { return proto.CompactTextString(m) }
func (*AnalyseResponse_Terms) ProtoMessage()               {}
func (*AnalyseResponse_Terms) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 0} }

func (m *AnalyseResponse_Terms) GetTerms() []string {
	if m != nil {
		return m.Terms
	}
	return nil
}

func init() {
	proto.RegisterType((*SearchRequest)(nil), "sajari.engine.query.SearchRequest")
	proto.RegisterType((*Transform)(nil), "sajari.engine.query.Transform")
	proto.RegisterType((*Term)(nil), "sajari.engine.query.Term")
	proto.RegisterType((*EvaluateRequest)(nil), "sajari.engine.query.EvaluateRequest")
	proto.RegisterType((*SubstituteRequest)(nil), "sajari.engine.query.SubstituteRequest")
	proto.RegisterType((*Body)(nil), "sajari.engine.query.Body")
	proto.RegisterType((*Aggregate)(nil), "sajari.engine.query.Aggregate")
	proto.RegisterType((*Aggregate_Metric)(nil), "sajari.engine.query.Aggregate.Metric")
	proto.RegisterType((*Aggregate_Count)(nil), "sajari.engine.query.Aggregate.Count")
	proto.RegisterType((*Aggregate_Bucket)(nil), "sajari.engine.query.Aggregate.Bucket")
	proto.RegisterType((*Aggregate_Bucket_Bucket)(nil), "sajari.engine.query.Aggregate.Bucket.Bucket")
	proto.RegisterType((*Sort)(nil), "sajari.engine.query.Sort")
	proto.RegisterType((*Filter)(nil), "sajari.engine.query.Filter")
	proto.RegisterType((*Filter_Field)(nil), "sajari.engine.query.Filter.Field")
	proto.RegisterType((*Filter_Geo)(nil), "sajari.engine.query.Filter.Geo")
	proto.RegisterType((*Filter_Combinator)(nil), "sajari.engine.query.Filter.Combinator")
	proto.RegisterType((*FieldBoost)(nil), "sajari.engine.query.FieldBoost")
	proto.RegisterType((*FieldBoost_Additive)(nil), "sajari.engine.query.FieldBoost.Additive")
	proto.RegisterType((*FieldBoost_Filter)(nil), "sajari.engine.query.FieldBoost.Filter")
	proto.RegisterType((*FieldBoost_Interval)(nil), "sajari.engine.query.FieldBoost.Interval")
	proto.RegisterType((*FieldBoost_Interval_Point)(nil), "sajari.engine.query.FieldBoost.Interval.Point")
	proto.RegisterType((*FieldBoost_Distance)(nil), "sajari.engine.query.FieldBoost.Distance")
	proto.RegisterType((*FieldBoost_Element)(nil), "sajari.engine.query.FieldBoost.Element")
	proto.RegisterType((*FieldBoost_Text)(nil), "sajari.engine.query.FieldBoost.Text")
	proto.RegisterType((*InstanceBoost)(nil), "sajari.engine.query.InstanceBoost")
	proto.RegisterType((*InstanceBoost_Field)(nil), "sajari.engine.query.InstanceBoost.Field")
	proto.RegisterType((*InstanceBoost_Score)(nil), "sajari.engine.query.InstanceBoost.Score")
	proto.RegisterType((*AggregateResponse)(nil), "sajari.engine.query.AggregateResponse")
	proto.RegisterType((*AggregateResponse_Metric)(nil), "sajari.engine.query.AggregateResponse.Metric")
	proto.RegisterType((*AggregateResponse_Count)(nil), "sajari.engine.query.AggregateResponse.Count")
	proto.RegisterType((*AggregateResponse_Buckets)(nil), "sajari.engine.query.AggregateResponse.Buckets")
	proto.RegisterType((*AggregateResponse_Buckets_Bucket)(nil), "sajari.engine.query.AggregateResponse.Buckets.Bucket")
	proto.RegisterType((*SearchResponse)(nil), "sajari.engine.query.SearchResponse")
	proto.RegisterType((*Result)(nil), "sajari.engine.query.Result")
	proto.RegisterType((*AnalyseRequest)(nil), "sajari.engine.query.AnalyseRequest")
	proto.RegisterType((*AnalyseResponse)(nil), "sajari.engine.query.AnalyseResponse")
	proto.RegisterType((*AnalyseResponse_Terms)(nil), "sajari.engine.query.AnalyseResponse.Terms")
	proto.RegisterEnum("sajari.engine.query.Aggregate_Metric_Type", Aggregate_Metric_Type_name, Aggregate_Metric_Type_value)
	proto.RegisterEnum("sajari.engine.query.Sort_Order", Sort_Order_name, Sort_Order_value)
	proto.RegisterEnum("sajari.engine.query.Filter_Field_Operator", Filter_Field_Operator_name, Filter_Field_Operator_value)
	proto.RegisterEnum("sajari.engine.query.Filter_Geo_Region", Filter_Geo_Region_name, Filter_Geo_Region_value)
	proto.RegisterEnum("sajari.engine.query.Filter_Combinator_Operator", Filter_Combinator_Operator_name, Filter_Combinator_Operator_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Query service

type QueryClient interface {
	// Search takes a search request and returns a corresponding response containing.
	// the search results and additional information on the search.
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// Evaluate takes a search request and a document and runs the search against
	// the document only.
	Evaluate(ctx context.Context, in *EvaluateRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// Substitute takes a search request and a document and substitutes the document values
	// in the request.
	Substitute(ctx context.Context, in *SubstituteRequest, opts ...grpc.CallOption) (*SearchRequest, error)
	// Analyse takes an AnalyseRequest (comprised of a search query and a document identifier) and computes
	// the term overlap between the two.
	Analyse(ctx context.Context, in *AnalyseRequest, opts ...grpc.CallOption) (*AnalyseResponse, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.query.Query/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Evaluate(ctx context.Context, in *EvaluateRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.query.Query/Evaluate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Substitute(ctx context.Context, in *SubstituteRequest, opts ...grpc.CallOption) (*SearchRequest, error) {
	out := new(SearchRequest)
	err := grpc.Invoke(ctx, "/sajari.engine.query.Query/Substitute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Analyse(ctx context.Context, in *AnalyseRequest, opts ...grpc.CallOption) (*AnalyseResponse, error) {
	out := new(AnalyseResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.query.Query/Analyse", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Query service

type QueryServer interface {
	// Search takes a search request and returns a corresponding response containing.
	// the search results and additional information on the search.
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	// Evaluate takes a search request and a document and runs the search against
	// the document only.
	Evaluate(context.Context, *EvaluateRequest) (*SearchResponse, error)
	// Substitute takes a search request and a document and substitutes the document values
	// in the request.
	Substitute(context.Context, *SubstituteRequest) (*SearchRequest, error)
	// Analyse takes an AnalyseRequest (comprised of a search query and a document identifier) and computes
	// the term overlap between the two.
	Analyse(context.Context, *AnalyseRequest) (*AnalyseResponse, error)
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.query.Query/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Evaluate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Evaluate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.query.Query/Evaluate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Evaluate(ctx, req.(*EvaluateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Substitute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubstituteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Substitute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.query.Query/Substitute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Substitute(ctx, req.(*SubstituteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Analyse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Analyse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.query.Query/Analyse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Analyse(ctx, req.(*AnalyseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sajari.engine.query.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _Query_Search_Handler,
		},
		{
			MethodName: "Evaluate",
			Handler:    _Query_Evaluate_Handler,
		},
		{
			MethodName: "Substitute",
			Handler:    _Query_Substitute_Handler,
		},
		{
			MethodName: "Analyse",
			Handler:    _Query_Analyse_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sajari/engine/query/query.proto",
}

func init() { proto.RegisterFile("sajari/engine/query/query.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2071 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x59, 0x4b, 0x6f, 0x1b, 0xc9,
	0x11, 0xe6, 0x90, 0x1c, 0x3e, 0x8a, 0x22, 0x3d, 0xdb, 0xd1, 0x26, 0xf4, 0xec, 0xae, 0xad, 0x1d,
	0x3b, 0x5a, 0xc1, 0x59, 0x53, 0x81, 0xb4, 0x06, 0xf6, 0x05, 0xc7, 0xa4, 0x44, 0x3d, 0x62, 0x99,
	0x94, 0x9b, 0xd4, 0xc2, 0x39, 0x04, 0xc4, 0x48, 0x6c, 0xd1, 0x13, 0x93, 0x33, 0xf4, 0x4c, 0xd3,
	0x36, 0xcf, 0x39, 0x04, 0xc8, 0x39, 0xd7, 0x04, 0x08, 0x72, 0x0b, 0x10, 0x20, 0x7f, 0x21, 0x87,
	0x00, 0xb9, 0x04, 0x08, 0x72, 0x0e, 0x02, 0x04, 0xc8, 0x25, 0x87, 0xfc, 0x87, 0xa0, 0x5f, 0xc3,
	0x19, 0x9a, 0x8f, 0xd9, 0x00, 0xbe, 0x88, 0xdd, 0x35, 0x55, 0x5f, 0x57, 0x75, 0x55, 0x57, 0x57,
	0xb5, 0xe0, 0x76, 0x60, 0xff, 0xcc, 0xf6, 0x9d, 0x5d, 0xe2, 0x0e, 0x1c, 0x97, 0xec, 0xbe, 0x9c,
	0x10, 0x7f, 0x2a, 0xfe, 0xd6, 0xc6, 0xbe, 0x47, 0x3d, 0xf4, 0x1d, 0xc1, 0x50, 0x13, 0x0c, 0x35,
	0xfe, 0xc9, 0xbc, 0x19, 0x97, 0x7a, 0x65, 0x0f, 0x27, 0x44, 0xf0, 0x9b, 0x66, 0xfc, 0x53, 0x40,
	0x6d, 0x3a, 0x09, 0xe4, 0xb7, 0xef, 0xc5, 0xbf, 0xbd, 0x20, 0x72, 0x11, 0xeb, 0x0f, 0x3a, 0x94,
	0x3b, 0xc4, 0xf6, 0xaf, 0x9e, 0x63, 0xf2, 0x72, 0x42, 0x02, 0x8a, 0xee, 0x43, 0xf6, 0xd2, 0xeb,
	0x4f, 0xab, 0xda, 0x56, 0x66, 0xa7, 0xb4, 0x77, 0xb3, 0xb6, 0x40, 0x8b, 0x5a, 0xc3, 0xeb, 0x4f,
	0x31, 0x67, 0x43, 0xbb, 0xa0, 0x53, 0xe2, 0x8f, 0x82, 0x6a, 0x7a, 0x05, 0x7f, 0x97, 0xf8, 0x23,
	0x2c, 0xf8, 0xd0, 0x3e, 0xe4, 0xae, 0x9d, 0x21, 0x25, 0x7e, 0x35, 0xb3, 0xa5, 0xed, 0x94, 0xf6,
	0x3e, 0x58, 0x28, 0x71, 0xc4, 0x59, 0xb0, 0x64, 0x45, 0x0d, 0xd8, 0xb8, 0x76, 0xc8, 0xb0, 0xdf,
	0xbb, 0xf4, 0xbc, 0x80, 0x06, 0xd5, 0x2c, 0x5f, 0xec, 0xf6, 0x12, 0x51, 0x32, 0xec, 0x37, 0x18,
	0x1f, 0x2e, 0x5d, 0x87, 0xe3, 0x00, 0x3d, 0x86, 0x1b, 0x8e, 0x1b, 0x50, 0xdb, 0xbd, 0x22, 0x0a,
	0x46, 0xe7, 0x30, 0xd6, 0x42, 0x98, 0x53, 0xc9, 0x2b, 0x90, 0x2a, 0x4e, 0x74, 0x1a, 0x20, 0x04,
	0xd9, 0xb1, 0x3d, 0x20, 0xd5, 0xdc, 0x96, 0xb6, 0xa3, 0x63, 0x3e, 0x46, 0x3b, 0x60, 0xf8, 0x24,
	0x98, 0x0c, 0x69, 0xd0, 0x1b, 0x13, 0xbf, 0xc7, 0xbf, 0xe7, 0xf9, 0xf7, 0x8a, 0xa4, 0x9f, 0x13,
	0xff, 0x9c, 0x71, 0x7e, 0x97, 0xed, 0x01, 0x19, 0xf6, 0x83, 0x6a, 0x61, 0x2b, 0xb3, 0x53, 0xc4,
	0x72, 0xc6, 0xf6, 0x3e, 0xf0, 0x7c, 0x5a, 0x2d, 0xae, 0xd8, 0xcb, 0x8e, 0xe7, 0x53, 0xcc, 0xd9,
	0x10, 0x06, 0xb0, 0x07, 0x03, 0x9f, 0x0c, 0x6c, 0x4a, 0x82, 0x2a, 0x70, 0xa1, 0xbd, 0xc5, 0x42,
	0x51, 0x17, 0xd7, 0xea, 0xa1, 0x50, 0xd3, 0xa5, 0xfe, 0x14, 0x47, 0x50, 0xd0, 0x43, 0x00, 0xea,
	0xdb, 0x6e, 0x70, 0xed, 0x31, 0xa7, 0x96, 0x38, 0xe6, 0xad, 0xc5, 0x4e, 0x55, 0x6c, 0x38, 0x22,
	0x61, 0xfe, 0x14, 0x6e, 0xcc, 0xc1, 0x23, 0x03, 0x32, 0x2f, 0x08, 0x0b, 0x28, 0x6d, 0xa7, 0x88,
	0xd9, 0x10, 0x7d, 0x06, 0x3a, 0x8f, 0xdc, 0x6a, 0x9a, 0x87, 0xc0, 0x62, 0xfc, 0x10, 0x06, 0x0b,
	0xe6, 0x2f, 0xd3, 0x9f, 0x6b, 0xd6, 0x0f, 0xa0, 0x18, 0xae, 0x8b, 0x6e, 0x01, 0x38, 0x7d, 0xe2,
	0x52, 0xe7, 0xda, 0x21, 0xbe, 0xc4, 0x8f, 0x50, 0xac, 0x3f, 0x6a, 0x90, 0x65, 0xa1, 0x87, 0x36,
	0xd5, 0x7a, 0x82, 0x47, 0x4c, 0x18, 0x95, 0xef, 0x3b, 0xd7, 0xa2, 0x88, 0xc5, 0x84, 0x69, 0x3b,
	0xf6, 0x02, 0x1e, 0x9c, 0x65, 0xcc, 0x86, 0x8c, 0xe2, 0x92, 0x41, 0x35, 0x2b, 0x28, 0x2e, 0x19,
	0x30, 0xff, 0xbd, 0x26, 0xce, 0xe0, 0x39, 0xad, 0xea, 0x5b, 0xda, 0x8e, 0x86, 0xe5, 0x0c, 0xdd,
	0x86, 0xd2, 0x6b, 0xcf, 0xef, 0xf7, 0xbc, 0xeb, 0xeb, 0x80, 0x50, 0x1e, 0x1c, 0x65, 0x0c, 0x8c,
	0xd4, 0xe6, 0x14, 0xc6, 0x30, 0xb6, 0x7d, 0x5b, 0x31, 0xe4, 0x05, 0x03, 0x23, 0x09, 0x06, 0xeb,
	0x3f, 0x1a, 0xdc, 0x68, 0x32, 0xf5, 0x98, 0xdd, 0xf2, 0x44, 0x9e, 0x42, 0x25, 0xe0, 0xfe, 0xeb,
	0xf9, 0x82, 0xc2, 0xcd, 0x58, 0x16, 0xb7, 0x31, 0x57, 0xe3, 0x72, 0x10, 0x3b, 0xdc, 0x2d, 0x28,
	0xf4, 0xbd, 0xab, 0xc9, 0x88, 0xb8, 0x54, 0x1e, 0xd8, 0xc5, 0xf1, 0x32, 0xa7, 0x42, 0xed, 0x50,
	0x0a, 0x89, 0x78, 0x09, 0x31, 0xcc, 0xaf, 0xa0, 0x1c, 0xfb, 0xb4, 0xc0, 0xd7, 0x9b, 0x51, 0x5f,
	0x6f, 0x44, 0x7d, 0xf9, 0x5f, 0x0d, 0xde, 0xeb, 0x4c, 0x2e, 0x03, 0xea, 0xd0, 0xc9, 0x3b, 0xb1,
	0xf6, 0xfc, 0x2d, 0x6b, 0x3f, 0x5b, 0x0c, 0x32, 0xaf, 0xc4, 0xbb, 0xb1, 0x77, 0x0f, 0xb2, 0x2c,
	0x71, 0xb2, 0xdc, 0x41, 0xc9, 0x1b, 0x2a, 0x85, 0xf8, 0x38, 0x12, 0x51, 0xe9, 0x68, 0x44, 0x59,
	0xbf, 0xcf, 0x42, 0x31, 0x3c, 0x08, 0xe8, 0x47, 0x90, 0x1b, 0x11, 0xea, 0x3b, 0x57, 0x72, 0x4f,
	0xbe, 0xbf, 0xfa, 0xe0, 0xd4, 0x9e, 0x70, 0xe6, 0x93, 0x14, 0x96, 0x62, 0xe8, 0x6b, 0xd0, 0xaf,
	0xbc, 0x89, 0x4b, 0xe5, 0xc1, 0xbb, 0xbb, 0x46, 0xfe, 0x80, 0xf1, 0x9e, 0xa4, 0xb0, 0x10, 0x62,
	0xcb, 0x5f, 0x4e, 0xae, 0x5e, 0x10, 0x2a, 0x53, 0xf7, 0xba, 0xe5, 0x1b, 0x9c, 0x99, 0x2d, 0x2f,
	0xc4, 0xcc, 0x5f, 0x6a, 0x90, 0x13, 0x3a, 0xcd, 0x0e, 0x9f, 0x16, 0x3d, 0x7c, 0x0f, 0x21, 0x4b,
	0xa7, 0x63, 0xb1, 0x77, 0x95, 0xbd, 0x7b, 0x89, 0xcc, 0xab, 0x75, 0xa7, 0x63, 0x82, 0xb9, 0x9c,
	0x75, 0x0f, 0xb2, 0x6c, 0x86, 0xf2, 0x90, 0xa9, 0x7f, 0x73, 0x6c, 0xa4, 0xd8, 0xe0, 0xc9, 0x69,
	0xcb, 0xd0, 0xf8, 0xa0, 0xfe, 0xcc, 0x48, 0xb3, 0x41, 0xe7, 0xe2, 0x89, 0x91, 0x31, 0x3f, 0x02,
	0x9d, 0xdb, 0xb7, 0x58, 0x15, 0xf3, 0x77, 0x1a, 0xe4, 0x84, 0x01, 0xe8, 0x08, 0xf2, 0xc2, 0x80,
	0x40, 0xde, 0x8a, 0x9f, 0x26, 0x32, 0x5c, 0xfe, 0x60, 0x25, 0x6c, 0x3e, 0x0d, 0x11, 0x11, 0x64,
	0x5d, 0x7b, 0xa4, 0xf2, 0x11, 0x1f, 0x47, 0x2e, 0xc6, 0x74, 0xe2, 0x8b, 0xb1, 0x51, 0x82, 0x62,
	0x98, 0xbc, 0x2d, 0x0f, 0xb2, 0xec, 0x76, 0x58, 0xb2, 0xb7, 0x0f, 0x40, 0xf7, 0xfc, 0xbe, 0x84,
	0xaf, 0x2c, 0xb9, 0x3c, 0x99, 0x7c, 0xad, 0xcd, 0xd8, 0xb0, 0xe0, 0xb6, 0x4c, 0xd0, 0xf9, 0x9c,
	0xef, 0x69, 0xe7, 0xc0, 0x48, 0xa1, 0x02, 0x64, 0x0f, 0x9b, 0x9d, 0x03, 0x43, 0xb3, 0xfe, 0x96,
	0x87, 0x9c, 0x50, 0x08, 0x9d, 0x00, 0x5c, 0x79, 0xa3, 0x4b, 0xc7, 0xb5, 0xa9, 0xe7, 0xcb, 0xf0,
	0xdc, 0x5e, 0x61, 0x41, 0xed, 0x20, 0xe4, 0x3e, 0x49, 0xe1, 0x88, 0x2c, 0xfa, 0x22, 0x9a, 0x96,
	0x4b, 0x7b, 0x1f, 0xaf, 0x02, 0xe1, 0x77, 0x3d, 0x0b, 0x50, 0x61, 0xe2, 0x3e, 0x64, 0x06, 0xc4,
	0x93, 0xd1, 0x79, 0x7b, 0x95, 0xe0, 0x31, 0xf1, 0x4e, 0x52, 0x98, 0x71, 0x9b, 0xff, 0x48, 0x83,
	0xce, 0x71, 0xd0, 0x11, 0x14, 0xbc, 0x31, 0xf1, 0x43, 0x0b, 0x96, 0x45, 0x60, 0x74, 0xf1, 0x5a,
	0x5b, 0x4a, 0xe0, 0x50, 0x76, 0xc9, 0xc5, 0x72, 0x4f, 0x25, 0x06, 0xa1, 0xde, 0xe6, 0x1c, 0xf4,
	0x37, 0xec, 0x9b, 0x4c, 0x17, 0xd6, 0x5f, 0x34, 0x28, 0x28, 0x60, 0xb4, 0x01, 0x85, 0xe6, 0xd3,
	0x8b, 0xfa, 0x59, 0xaf, 0xdb, 0x36, 0x52, 0xc8, 0x80, 0x8d, 0x56, 0xbb, 0xdb, 0x0b, 0x29, 0x1a,
	0xa3, 0x1c, 0xe3, 0x66, 0xbd, 0xdb, 0xc4, 0xbd, 0xee, 0x49, 0xbd, 0x65, 0xa4, 0xd1, 0x87, 0x50,
	0x8d, 0x52, 0x7a, 0x6d, 0x3c, 0xe3, 0xcf, 0xa0, 0x32, 0x14, 0xcf, 0x9a, 0x9d, 0x8e, 0x60, 0xce,
	0xa2, 0x9b, 0xf0, 0x7e, 0x38, 0x8d, 0x71, 0xea, 0x6c, 0xe5, 0x83, 0x76, 0xab, 0x5b, 0x3f, 0x6d,
	0x75, 0x8c, 0x1c, 0xda, 0x04, 0xe3, 0xb0, 0xdd, 0xec, 0xf4, 0xd8, 0xf2, 0x92, 0x6c, 0xe4, 0x51,
	0x05, 0xe0, 0xa4, 0xde, 0xe9, 0x75, 0x2e, 0x8e, 0x8e, 0x4e, 0x9f, 0x19, 0x05, 0x35, 0x3f, 0xc7,
	0x4d, 0x36, 0x2f, 0x9a, 0xff, 0xd4, 0x20, 0x73, 0x4c, 0x3c, 0xf4, 0x01, 0x14, 0x45, 0x09, 0x37,
	0xb4, 0x55, 0xea, 0x2b, 0x70, 0xc2, 0x99, 0x4d, 0x23, 0x1f, 0xdd, 0x81, 0xdc, 0x35, 0xf9, 0xd1,
	0x1d, 0xb0, 0x1c, 0xcb, 0x64, 0x32, 0x3c, 0x31, 0xb2, 0x21, 0xa7, 0xb8, 0xe2, 0x46, 0x66, 0x14,
	0x97, 0xdf, 0xc8, 0xbe, 0xdd, 0x77, 0x26, 0x81, 0xba, 0x91, 0xc5, 0x0c, 0x3d, 0x84, 0x9c, 0x4f,
	0x06, 0x8e, 0xe7, 0xf2, 0xcb, 0xb8, 0xb2, 0x3a, 0x24, 0x8f, 0x89, 0x57, 0xc3, 0x9c, 0x1b, 0x4b,
	0x29, 0xeb, 0x63, 0xc8, 0x09, 0x0a, 0x02, 0xc8, 0x9d, 0xb6, 0x3a, 0xa7, 0x87, 0x4d, 0x23, 0x85,
	0x4a, 0x90, 0x6f, 0x5f, 0x74, 0xf9, 0x44, 0x33, 0xff, 0xa4, 0x01, 0xcc, 0x82, 0x19, 0x3d, 0x7e,
	0x2b, 0x88, 0x76, 0x93, 0x1d, 0x83, 0x45, 0x91, 0xf4, 0x00, 0xf2, 0xe2, 0xa0, 0xab, 0xfa, 0x7a,
	0x65, 0x52, 0x50, 0xbc, 0xd6, 0x6e, 0x24, 0x7a, 0xd8, 0xb1, 0x3d, 0x3b, 0x13, 0xa9, 0xb0, 0xde,
	0xfa, 0x89, 0x48, 0x85, 0xed, 0x56, 0xd3, 0x48, 0xb3, 0x83, 0xdc, 0x62, 0xa3, 0x4c, 0xa3, 0xa0,
	0x72, 0x8f, 0xf5, 0xef, 0x3c, 0xc0, 0xac, 0x82, 0x66, 0x47, 0xc2, 0xee, 0xf7, 0x1d, 0xea, 0xbc,
	0x22, 0xf2, 0x50, 0xef, 0xac, 0x29, 0xba, 0x6b, 0x75, 0xc9, 0x7f, 0x92, 0xc2, 0xa1, 0x2c, 0x7a,
	0x34, 0x97, 0xdc, 0xb6, 0xd7, 0xa1, 0x08, 0x93, 0xd8, 0xdd, 0x21, 0x5b, 0x80, 0x23, 0x28, 0x38,
	0x2e, 0x25, 0xfe, 0x2b, 0x7b, 0x28, 0x4f, 0xd0, 0x5a, 0x4d, 0x4e, 0x25, 0x3f, 0xd3, 0x44, 0xc9,
	0x32, 0x9c, 0xbe, 0x23, 0x6a, 0x79, 0x1e, 0x40, 0x09, 0x70, 0x0e, 0x25, 0x3f, 0xc3, 0x51, 0xb2,
	0xe8, 0x00, 0xf2, 0x64, 0x48, 0x78, 0x6d, 0xa1, 0x73, 0x98, 0x4f, 0xd6, 0xc1, 0x34, 0x05, 0xfb,
	0x49, 0x0a, 0x2b, 0x49, 0xf4, 0xa5, 0x2c, 0x05, 0x72, 0x2b, 0xae, 0xe3, 0x08, 0x42, 0x97, 0xbc,
	0x61, 0xe2, 0x5c, 0xc6, 0xbc, 0x84, 0x42, 0x7d, 0xb6, 0xbd, 0xa5, 0x48, 0x7f, 0x24, 0x3d, 0xb5,
	0xb6, 0x3d, 0x82, 0x59, 0x7b, 0x14, 0x2f, 0x5b, 0x34, 0x99, 0x87, 0xcc, 0x4e, 0x98, 0xdf, 0x67,
	0xb7, 0x93, 0x96, 0xbc, 0x6d, 0x5b, 0x0c, 0xfa, 0x6b, 0x0d, 0x0a, 0xca, 0x35, 0x4b, 0xee, 0xaa,
	0x23, 0xc8, 0x8d, 0x3d, 0xc7, 0xa5, 0x2a, 0xec, 0x6b, 0x49, 0x5d, 0x5d, 0x3b, 0x67, 0x62, 0x58,
	0x4a, 0x9b, 0xfb, 0xa0, 0x73, 0x02, 0x5b, 0x86, 0x93, 0xf8, 0x32, 0x1a, 0x16, 0x93, 0x25, 0xfa,
	0x0d, 0xa1, 0xa0, 0x3c, 0xce, 0x32, 0xcd, 0xc8, 0x71, 0xa5, 0x14, 0x1b, 0x72, 0x8a, 0xfd, 0x46,
	0x4a, 0xb0, 0x21, 0xa3, 0xf8, 0xe4, 0x5a, 0xe5, 0x27, 0x9f, 0x5c, 0xcf, 0x8c, 0xca, 0x46, 0x8d,
	0x0a, 0x57, 0xd3, 0xa3, 0xab, 0xed, 0x43, 0x5e, 0x06, 0xc6, 0x92, 0xbd, 0x40, 0x90, 0x25, 0x43,
	0xca, 0x3a, 0x12, 0xd6, 0x2a, 0xf2, 0xb1, 0xf9, 0x43, 0xd6, 0xd8, 0xbc, 0x59, 0x21, 0xc1, 0xa3,
	0x2a, 0x33, 0x2b, 0x30, 0x1b, 0xe5, 0x58, 0x84, 0x58, 0xbf, 0x49, 0x43, 0x39, 0xd6, 0xe1, 0xa2,
	0x47, 0x51, 0xa8, 0x65, 0x87, 0x22, 0x26, 0x32, 0x7f, 0xfb, 0x3e, 0x02, 0x3d, 0xb8, 0xf2, 0x7c,
	0xd5, 0xd5, 0x25, 0x41, 0xe8, 0x30, 0x7e, 0x86, 0xc0, 0x05, 0x99, 0xbb, 0x8e, 0xd4, 0x56, 0x2d,
	0xb0, 0x6b, 0xb1, 0xbb, 0x1a, 0xa0, 0x73, 0x18, 0xf4, 0x21, 0x14, 0xe9, 0x73, 0x9f, 0x04, 0xcf,
	0x3d, 0x29, 0xa8, 0xe1, 0x19, 0x81, 0x5d, 0x31, 0x23, 0xc7, 0xed, 0xcd, 0xca, 0xdf, 0x32, 0x2e,
	0x8c, 0x1c, 0x97, 0x97, 0x80, 0x0d, 0x03, 0x2a, 0xf1, 0xb7, 0x01, 0xeb, 0xcf, 0x3a, 0xbc, 0x37,
	0xeb, 0x40, 0x49, 0x30, 0xf6, 0xdc, 0x80, 0xa0, 0xe3, 0xb9, 0x02, 0xfc, 0xfe, 0x9a, 0xce, 0x55,
	0xca, 0xbd, 0x5d, 0x88, 0x1f, 0xc6, 0x0b, 0xf1, 0x4f, 0x13, 0xe2, 0xcc, 0x15, 0xe4, 0x3f, 0x9e,
	0x15, 0xa6, 0x22, 0x25, 0xd6, 0x12, 0xe2, 0x88, 0x32, 0x34, 0x60, 0xa9, 0x48, 0x15, 0xa7, 0xb7,
	0xa2, 0xa5, 0xf9, 0xac, 0x5b, 0x0e, 0xb7, 0xf9, 0x57, 0x9a, 0xaa, 0x97, 0xcf, 0x21, 0xc7, 0x97,
	0x57, 0xd5, 0xf0, 0xe7, 0xdf, 0x46, 0x79, 0xf1, 0x57, 0x3e, 0x3c, 0x48, 0x1c, 0xf3, 0x0b, 0x28,
	0x45, 0xc8, 0xeb, 0x9a, 0x2a, 0x3d, 0xd2, 0x54, 0x99, 0xbf, 0x48, 0x43, 0x5e, 0x5a, 0x83, 0x2e,
	0xe6, 0xeb, 0xf4, 0xaf, 0xbe, 0xdd, 0x76, 0xa8, 0x5f, 0xa1, 0x5c, 0xb8, 0x33, 0x7b, 0x2b, 0xcb,
	0xf6, 0xcd, 0xa8, 0x27, 0x75, 0xe9, 0x19, 0xf3, 0x25, 0x6c, 0x44, 0xc1, 0x16, 0x98, 0xf4, 0x38,
	0xfe, 0x06, 0xf2, 0xe0, 0xff, 0x52, 0x35, 0xb2, 0x13, 0x8d, 0x4d, 0x40, 0x61, 0x2b, 0xd0, 0xf3,
	0x25, 0xbf, 0xf5, 0xf7, 0x34, 0x54, 0x54, 0x93, 0x2c, 0x83, 0x78, 0x13, 0x74, 0x9f, 0xd8, 0xfd,
	0x80, 0x6b, 0x93, 0xc1, 0x62, 0x82, 0xee, 0x40, 0x99, 0x7a, 0xd4, 0x1e, 0xf6, 0xe4, 0x5b, 0x15,
	0xd7, 0x2b, 0x83, 0x37, 0x38, 0x11, 0x0b, 0x1a, 0xcf, 0x2c, 0xce, 0x88, 0x84, 0x99, 0xc5, 0x19,
	0x11, 0xd4, 0x89, 0xbd, 0x42, 0x89, 0x97, 0xb9, 0xfd, 0x95, 0xcd, 0xba, 0x34, 0x65, 0xd5, 0x33,
	0xd4, 0x03, 0xc8, 0x2b, 0x3d, 0xf4, 0x15, 0x85, 0x8f, 0xd0, 0x0b, 0x2b, 0x5e, 0x93, 0x24, 0x79,
	0x7d, 0xfa, 0x3a, 0xbe, 0xf3, 0xdb, 0xc9, 0x76, 0x3e, 0xda, 0xc9, 0xff, 0x55, 0x63, 0x65, 0x21,
	0x5b, 0x92, 0xf5, 0xc4, 0x9c, 0xae, 0x42, 0xee, 0x93, 0x15, 0x7a, 0x8a, 0x1a, 0x5f, 0xc5, 0xbe,
	0x10, 0x63, 0xde, 0x98, 0x65, 0x4d, 0x4d, 0x66, 0x42, 0x96, 0xad, 0x7c, 0xfb, 0x75, 0x4f, 0x7c,
	0x11, 0x37, 0x4b, 0xc1, 0xb7, 0x5f, 0xf3, 0x44, 0x67, 0xb6, 0xa1, 0x14, 0x41, 0x5a, 0x60, 0xe1,
	0xbd, 0xb8, 0x85, 0xab, 0x5a, 0x0d, 0x6e, 0xcf, 0xcf, 0x35, 0xa8, 0xd4, 0x5d, 0x7b, 0x38, 0x0d,
	0xde, 0xc5, 0x33, 0xcc, 0x36, 0x64, 0x5f, 0x90, 0xa9, 0xba, 0xca, 0xd1, 0x1c, 0xc0, 0x63, 0x32,
	0xc5, 0xfc, 0xbb, 0xf5, 0x5b, 0x0d, 0x6e, 0x84, 0x5a, 0xc8, 0x58, 0x7d, 0xa4, 0x9e, 0x97, 0xc5,
	0xee, 0x2e, 0x79, 0x11, 0x88, 0x0b, 0xf1, 0xe7, 0xe6, 0x40, 0xbd, 0x37, 0xdf, 0x87, 0x9c, 0x78,
	0x0a, 0x97, 0xeb, 0xbf, 0x3f, 0x07, 0xd1, 0xe1, 0x1f, 0xb1, 0x64, 0x32, 0x3f, 0x02, 0x9d, 0x8b,
	0x33, 0xbf, 0xcc, 0x56, 0x2e, 0x4a, 0xb4, 0xbd, 0x7f, 0xa5, 0x41, 0x7f, 0xca, 0x16, 0x45, 0x4f,
	0x21, 0x27, 0xac, 0x46, 0x09, 0xb6, 0xc4, 0xbc, 0x93, 0xe0, 0x40, 0xa0, 0x0b, 0x28, 0xa8, 0x87,
	0x37, 0x74, 0x37, 0xc9, 0xbb, 0x5c, 0x32, 0xd8, 0x67, 0x00, 0xb3, 0x17, 0x2e, 0xb4, 0x9d, 0xec,
	0x09, 0xcc, 0x4c, 0x60, 0x15, 0xea, 0x42, 0x5e, 0xee, 0x3d, 0xba, 0xb3, 0xda, 0x33, 0x02, 0xf3,
	0x6e, 0x12, 0xf7, 0x5d, 0xe6, 0xf8, 0xbf, 0x26, 0xf6, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xcd,
	0x2a, 0x0f, 0x57, 0x22, 0x19, 0x00, 0x00,
}
