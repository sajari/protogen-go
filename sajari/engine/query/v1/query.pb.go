// Code generated by protoc-gen-go.
// source: sajari/engine/query/v1/query.proto
// DO NOT EDIT!

/*
Package sajari_engine_query_v1 is a generated protocol buffer package.

It is generated from these files:
	sajari/engine/query/v1/query.proto

It has these top-level messages:
	SearchRequest
	Transform
	Term
	EvaluateRequest
	SubstituteRequest
	Body
	Aggregate
	Sort
	Filter
	FieldBoost
	InstanceBoost
	AggregateResponse
	SearchResponse
	Result
	AnalyseRequest
	AnalyseResponse
*/
package sajari_engine_query_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import sajari_engine "github.com/sajari/protogen-go/sajari/engine"
import sajari_engine1 "github.com/sajari/protogen-go/sajari/engine"
import sajari_rpc "github.com/sajari/protogen-go/sajari/rpc"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Enumeration of metric types.
type Aggregate_Metric_Type int32

const (
	// Average field value.
	Aggregate_Metric_AVG Aggregate_Metric_Type = 0
	// Minimum field value.
	Aggregate_Metric_MIN Aggregate_Metric_Type = 1
	// Maximum field value.
	Aggregate_Metric_MAX Aggregate_Metric_Type = 2
	// Sum of all field values.
	Aggregate_Metric_SUM Aggregate_Metric_Type = 3
)

var Aggregate_Metric_Type_name = map[int32]string{
	0: "AVG",
	1: "MIN",
	2: "MAX",
	3: "SUM",
}
var Aggregate_Metric_Type_value = map[string]int32{
	"AVG": 0,
	"MIN": 1,
	"MAX": 2,
	"SUM": 3,
}

func (x Aggregate_Metric_Type) String() string {
	return proto.EnumName(Aggregate_Metric_Type_name, int32(x))
}
func (Aggregate_Metric_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0, 0} }

// Order is an enumeration that defines orderings for sorting.
type Sort_Order int32

const (
	// Ascending: from least to greatest, for non-numeric
	// fields this means alphabetical order.
	Sort_ASC Sort_Order = 0
	// Descending: from greatest to least, for non-numeric
	// fields this means reverse-alphabetical order.
	Sort_DESC Sort_Order = 1
)

var Sort_Order_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var Sort_Order_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x Sort_Order) String() string {
	return proto.EnumName(Sort_Order_name, int32(x))
}
func (Sort_Order) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

// Operator is an enumeration of operators.
type Filter_Field_Operator int32

const (
	// Equal value.
	// For STRING fields this is case insensitive.
	Filter_Field_EQUAL_TO Filter_Field_Operator = 0
	// Not equal value.
	// For STRING fields this is case insensitive.
	Filter_Field_NOT_EQUAL_TO             Filter_Field_Operator = 1
	Filter_Field_GREATER_THAN             Filter_Field_Operator = 2
	Filter_Field_GREATER_THAN_OR_EQUAL_TO Filter_Field_Operator = 3
	Filter_Field_LESS_THAN                Filter_Field_Operator = 4
	Filter_Field_LESS_THAN_OR_EQUAL_TO    Filter_Field_Operator = 5
	// For STRING fields this is case insensitive.
	Filter_Field_CONTAINS Filter_Field_Operator = 6
	// For STRING fields this is case insensitive.
	Filter_Field_DOES_NOT_CONTAIN Filter_Field_Operator = 7
	// For STRING fields this is case insensitive.
	Filter_Field_HAS_SUFFIX Filter_Field_Operator = 8
	// For STRING fields this is case insensitive.
	Filter_Field_HAS_PREFIX Filter_Field_Operator = 9
)

var Filter_Field_Operator_name = map[int32]string{
	0: "EQUAL_TO",
	1: "NOT_EQUAL_TO",
	2: "GREATER_THAN",
	3: "GREATER_THAN_OR_EQUAL_TO",
	4: "LESS_THAN",
	5: "LESS_THAN_OR_EQUAL_TO",
	6: "CONTAINS",
	7: "DOES_NOT_CONTAIN",
	8: "HAS_SUFFIX",
	9: "HAS_PREFIX",
}
var Filter_Field_Operator_value = map[string]int32{
	"EQUAL_TO":                 0,
	"NOT_EQUAL_TO":             1,
	"GREATER_THAN":             2,
	"GREATER_THAN_OR_EQUAL_TO": 3,
	"LESS_THAN":                4,
	"LESS_THAN_OR_EQUAL_TO":    5,
	"CONTAINS":                 6,
	"DOES_NOT_CONTAIN":         7,
	"HAS_SUFFIX":               8,
	"HAS_PREFIX":               9,
}

func (x Filter_Field_Operator) String() string {
	return proto.EnumName(Filter_Field_Operator_name, int32(x))
}
func (Filter_Field_Operator) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0, 0} }

// Region is an enumeration that defines regions for geo-boosting.
type Filter_Geo_Region int32

const (
	// Inside is used to configure a geo filter to be
	// satisfied on all points within the radius.
	Filter_Geo_INSIDE Filter_Geo_Region = 0
	// Outside is used to configure a geo filter to be
	// satisfied to all points outside the radius.
	Filter_Geo_OUTSIDE Filter_Geo_Region = 1
)

var Filter_Geo_Region_name = map[int32]string{
	0: "INSIDE",
	1: "OUTSIDE",
}
var Filter_Geo_Region_value = map[string]int32{
	"INSIDE":  0,
	"OUTSIDE": 1,
}

func (x Filter_Geo_Region) String() string {
	return proto.EnumName(Filter_Geo_Region_name, int32(x))
}
func (Filter_Geo_Region) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1, 0} }

// Operator is an enumeration of combination operators.
type Filter_Combinator_Operator int32

const (
	// All of the filters must be satisfied.
	Filter_Combinator_ALL Filter_Combinator_Operator = 0
	// Any of the filters must be satisfied.
	Filter_Combinator_ANY Filter_Combinator_Operator = 1
	// One of the filters (and only one) must be satisfied.
	Filter_Combinator_ONE Filter_Combinator_Operator = 2
	// None of the filters must be satisfied.
	Filter_Combinator_NONE Filter_Combinator_Operator = 3
)

var Filter_Combinator_Operator_name = map[int32]string{
	0: "ALL",
	1: "ANY",
	2: "ONE",
	3: "NONE",
}
var Filter_Combinator_Operator_value = map[string]int32{
	"ALL":  0,
	"ANY":  1,
	"ONE":  2,
	"NONE": 3,
}

func (x Filter_Combinator_Operator) String() string {
	return proto.EnumName(Filter_Combinator_Operator_name, int32(x))
}
func (Filter_Combinator_Operator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{8, 2, 0}
}

// SearchRequest contains all the parameters to query a collection.
//
// Records in the collection can be queried/scored using a combination of:
// 1. Field values (key-value pairs set by the user).  See Filter, FieldBoost, Sort.
// 2. Terms (extracted from the body of the record, or from string-based indexed fields,
//    i.e. full-text style searching).  See Body, Terms, InstanceBoost.
//
// Quering a collection follows three main steps:
// 1. Select suitable records to include in a result set.
// 2. Rank and sort the records based on scoring and/or sorting rules.
// 3. Compute and aggregate statistical information from the result set.
type SearchRequest struct {
	// Filter is a rule checked against record field values.
	//
	// Only records that match the filter will be included in the result.
	// By default all records are included.
	Filter *Filter `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
	// IndexQuery is the matching configuration for index-based matching.
	IndexQuery *SearchRequest_IndexQuery `protobuf:"bytes,2,opt,name=index_query,json=indexQuery" json:"index_query,omitempty"`
	// Feature query is the matching configuration for feature-based matching.
	FeatureQuery *SearchRequest_FeatureQuery `protobuf:"bytes,3,opt,name=feature_query,json=featureQuery" json:"feature_query,omitempty"`
	// Offset is the offset to return results from.
	Offset int32 `protobuf:"varint,4,opt,name=offset" json:"offset,omitempty"`
	// Limit is the number of results to return.
	Limit int32 `protobuf:"varint,5,opt,name=limit" json:"limit,omitempty"`
	// Fields to be returned for each record in the results.
	// By default all fields are returned.
	Fields []string `protobuf:"bytes,6,rep,name=fields" json:"fields,omitempty"`
	// Sort ordering applied to results.
	// Multiple sorts can be applied sequentially.
	// By default all results are ordered by score.
	Sort []*Sort `protobuf:"bytes,7,rep,name=sort" json:"sort,omitempty"`
	// A set of Aggregates to be run on the result set.
	Aggregates map[string]*Aggregate `protobuf:"bytes,8,rep,name=aggregates" json:"aggregates,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Transforms to be applied to the request before it is run.
	Transforms []*Transform `protobuf:"bytes,9,rep,name=transforms" json:"transforms,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SearchRequest) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *SearchRequest) GetIndexQuery() *SearchRequest_IndexQuery {
	if m != nil {
		return m.IndexQuery
	}
	return nil
}

func (m *SearchRequest) GetFeatureQuery() *SearchRequest_FeatureQuery {
	if m != nil {
		return m.FeatureQuery
	}
	return nil
}

func (m *SearchRequest) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SearchRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchRequest) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SearchRequest) GetSort() []*Sort {
	if m != nil {
		return m.Sort
	}
	return nil
}

func (m *SearchRequest) GetAggregates() map[string]*Aggregate {
	if m != nil {
		return m.Aggregates
	}
	return nil
}

func (m *SearchRequest) GetTransforms() []*Transform {
	if m != nil {
		return m.Transforms
	}
	return nil
}

// IndexQuery defines criteria for matching and scoring records based on full-text style
// term matching and record field values.
//
// All boost applied here are multiplicative.
type SearchRequest_IndexQuery struct {
	// Body is a list of weighted free text.
	Body []*Body `protobuf:"bytes,1,rep,name=body" json:"body,omitempty"`
	// Terms is a list of weighted terms, where terms represent tokenised sequences of text.
	Terms []*Term `protobuf:"bytes,2,rep,name=terms" json:"terms,omitempty"`
	// InstanceBoosts are boost rules computed against a record's term instances.
	//
	// Instance boosting allows callers to boost records which have terms that match
	// a rule.
	InstanceBoosts []*InstanceBoost `protobuf:"bytes,3,rep,name=instance_boosts,json=instanceBoosts" json:"instance_boosts,omitempty"`
	// FieldBoosts are rules checked against a record's field values.
	//
	// Field boosting allows callers to boost records which have field values that
	// match a rule.
	FieldBoosts []*FieldBoost `protobuf:"bytes,4,rep,name=field_boosts,json=fieldBoosts" json:"field_boosts,omitempty"`
}

func (m *SearchRequest_IndexQuery) Reset()                    { *m = SearchRequest_IndexQuery{} }
func (m *SearchRequest_IndexQuery) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest_IndexQuery) ProtoMessage()               {}
func (*SearchRequest_IndexQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *SearchRequest_IndexQuery) GetBody() []*Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *SearchRequest_IndexQuery) GetTerms() []*Term {
	if m != nil {
		return m.Terms
	}
	return nil
}

func (m *SearchRequest_IndexQuery) GetInstanceBoosts() []*InstanceBoost {
	if m != nil {
		return m.InstanceBoosts
	}
	return nil
}

func (m *SearchRequest_IndexQuery) GetFieldBoosts() []*FieldBoost {
	if m != nil {
		return m.FieldBoosts
	}
	return nil
}

// FeatureQuery defines criteria for boosting
type SearchRequest_FeatureQuery struct {
	// A list of field boosts.
	FieldBoosts []*SearchRequest_FeatureQuery_FieldBoost `protobuf:"bytes,1,rep,name=field_boosts,json=fieldBoosts" json:"field_boosts,omitempty"`
}

func (m *SearchRequest_FeatureQuery) Reset()                    { *m = SearchRequest_FeatureQuery{} }
func (m *SearchRequest_FeatureQuery) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest_FeatureQuery) ProtoMessage()               {}
func (*SearchRequest_FeatureQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 1} }

func (m *SearchRequest_FeatureQuery) GetFieldBoosts() []*SearchRequest_FeatureQuery_FieldBoost {
	if m != nil {
		return m.FieldBoosts
	}
	return nil
}

// FieldBoost is a boost is a feature boost on a field.
type SearchRequest_FeatureQuery_FieldBoost struct {
	// FieldBoost to make a feature boost.
	FieldBoost *FieldBoost `protobuf:"bytes,1,opt,name=field_boost,json=fieldBoost" json:"field_boost,omitempty"`
	// Amount this boost will contribute to the overall score of the record.
	//
	// Must be between 0 and 1.
	Value float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *SearchRequest_FeatureQuery_FieldBoost) Reset()         { *m = SearchRequest_FeatureQuery_FieldBoost{} }
func (m *SearchRequest_FeatureQuery_FieldBoost) String() string { return proto.CompactTextString(m) }
func (*SearchRequest_FeatureQuery_FieldBoost) ProtoMessage()    {}
func (*SearchRequest_FeatureQuery_FieldBoost) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 1, 0}
}

func (m *SearchRequest_FeatureQuery_FieldBoost) GetFieldBoost() *FieldBoost {
	if m != nil {
		return m.FieldBoost
	}
	return nil
}

func (m *SearchRequest_FeatureQuery_FieldBoost) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Transform is a transformation of the search request to be applied before
// the search is run. Transforms are typically used to extract additional
// features or to augment the input query itself.
type Transform struct {
	Identifier string `protobuf:"bytes,1,opt,name=identifier" json:"identifier,omitempty"`
}

func (m *Transform) Reset()                    { *m = Transform{} }
func (m *Transform) String() string            { return proto.CompactTextString(m) }
func (*Transform) ProtoMessage()               {}
func (*Transform) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Transform) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

// Term represents a tokenized piece of text (i.e. a single word, or number).
type Term struct {
	// Term string value.
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	// Field that the term originated from.
	Field string `protobuf:"bytes,2,opt,name=field" json:"field,omitempty"`
	// Number of positive interactions (uint16) this Term instance has been involved with.
	Pos uint32 `protobuf:"varint,3,opt,name=pos" json:"pos,omitempty"`
	// Number of negative interactions (uint16) this Term instance has been involved with.
	Neg uint32 `protobuf:"varint,4,opt,name=neg" json:"neg,omitempty"`
	// Significance of the term (uint16).
	Weight float64 `protobuf:"fixed64,5,opt,name=weight" json:"weight,omitempty"`
	// Word offset (context) (uint16).
	// The position of this term instance in it's immediate context (i.e. paragraph).
	WordOffset uint32 `protobuf:"varint,6,opt,name=word_offset,json=wordOffset" json:"word_offset,omitempty"`
	// Paragraph offset (context) (uint16).
	// The paragraph position (a grouping of term instances) in a body string.
	ParaOffset uint32 `protobuf:"varint,7,opt,name=para_offset,json=paraOffset" json:"para_offset,omitempty"`
}

func (m *Term) Reset()                    { *m = Term{} }
func (m *Term) String() string            { return proto.CompactTextString(m) }
func (*Term) ProtoMessage()               {}
func (*Term) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Term) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Term) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Term) GetPos() uint32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *Term) GetNeg() uint32 {
	if m != nil {
		return m.Neg
	}
	return 0
}

func (m *Term) GetWeight() float64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Term) GetWordOffset() uint32 {
	if m != nil {
		return m.WordOffset
	}
	return 0
}

func (m *Term) GetParaOffset() uint32 {
	if m != nil {
		return m.ParaOffset
	}
	return 0
}

// EvaluateRequest contains all parameters necessary to make an Evaluate call.
type EvaluateRequest struct {
	// Search request to run.
	SearchRequest *SearchRequest `protobuf:"bytes,1,opt,name=search_request,json=searchRequest" json:"search_request,omitempty"`
	// Record to search against.
	Record map[string]*sajari_engine.Value `protobuf:"bytes,2,rep,name=record" json:"record,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EvaluateRequest) Reset()                    { *m = EvaluateRequest{} }
func (m *EvaluateRequest) String() string            { return proto.CompactTextString(m) }
func (*EvaluateRequest) ProtoMessage()               {}
func (*EvaluateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EvaluateRequest) GetSearchRequest() *SearchRequest {
	if m != nil {
		return m.SearchRequest
	}
	return nil
}

func (m *EvaluateRequest) GetRecord() map[string]*sajari_engine.Value {
	if m != nil {
		return m.Record
	}
	return nil
}

type SubstituteRequest struct {
	// Request is used as a template
	SearchRequest *SearchRequest `protobuf:"bytes,1,opt,name=search_request,json=searchRequest" json:"search_request,omitempty"`
	// Record is the record to be substituted in the request.
	Record map[string]*sajari_engine.Value `protobuf:"bytes,2,rep,name=record" json:"record,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SubstituteRequest) Reset()                    { *m = SubstituteRequest{} }
func (m *SubstituteRequest) String() string            { return proto.CompactTextString(m) }
func (*SubstituteRequest) ProtoMessage()               {}
func (*SubstituteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SubstituteRequest) GetSearchRequest() *SearchRequest {
	if m != nil {
		return m.SearchRequest
	}
	return nil
}

func (m *SubstituteRequest) GetRecord() map[string]*sajari_engine.Value {
	if m != nil {
		return m.Record
	}
	return nil
}

// Body is a weighted free text query.
type Body struct {
	// Text (free text).
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
	// Weight (importance) to apply to this text.
	// This value must be 0 <= weight <= 1 but must be set. A value of zero means
	// the text has no value.
	Weight float64 `protobuf:"fixed64,2,opt,name=weight" json:"weight,omitempty"`
}

func (m *Body) Reset()                    { *m = Body{} }
func (m *Body) String() string            { return proto.CompactTextString(m) }
func (*Body) ProtoMessage()               {}
func (*Body) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Body) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Body) GetWeight() float64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// Aggregate is a statistical query run on the result set of a search.
type Aggregate struct {
	// Types that are valid to be assigned to Aggregate:
	//	*Aggregate_Metric_
	//	*Aggregate_Count_
	//	*Aggregate_Bucket_
	Aggregate isAggregate_Aggregate `protobuf_oneof:"aggregate"`
}

func (m *Aggregate) Reset()                    { *m = Aggregate{} }
func (m *Aggregate) String() string            { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()               {}
func (*Aggregate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isAggregate_Aggregate interface {
	isAggregate_Aggregate()
}

type Aggregate_Metric_ struct {
	Metric *Aggregate_Metric `protobuf:"bytes,1,opt,name=metric,oneof"`
}
type Aggregate_Count_ struct {
	Count *Aggregate_Count `protobuf:"bytes,2,opt,name=count,oneof"`
}
type Aggregate_Bucket_ struct {
	Bucket *Aggregate_Bucket `protobuf:"bytes,3,opt,name=bucket,oneof"`
}

func (*Aggregate_Metric_) isAggregate_Aggregate() {}
func (*Aggregate_Count_) isAggregate_Aggregate()  {}
func (*Aggregate_Bucket_) isAggregate_Aggregate() {}

func (m *Aggregate) GetAggregate() isAggregate_Aggregate {
	if m != nil {
		return m.Aggregate
	}
	return nil
}

func (m *Aggregate) GetMetric() *Aggregate_Metric {
	if x, ok := m.GetAggregate().(*Aggregate_Metric_); ok {
		return x.Metric
	}
	return nil
}

func (m *Aggregate) GetCount() *Aggregate_Count {
	if x, ok := m.GetAggregate().(*Aggregate_Count_); ok {
		return x.Count
	}
	return nil
}

func (m *Aggregate) GetBucket() *Aggregate_Bucket {
	if x, ok := m.GetAggregate().(*Aggregate_Bucket_); ok {
		return x.Bucket
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Aggregate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Aggregate_OneofMarshaler, _Aggregate_OneofUnmarshaler, _Aggregate_OneofSizer, []interface{}{
		(*Aggregate_Metric_)(nil),
		(*Aggregate_Count_)(nil),
		(*Aggregate_Bucket_)(nil),
	}
}

func _Aggregate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Aggregate)
	// aggregate
	switch x := m.Aggregate.(type) {
	case *Aggregate_Metric_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metric); err != nil {
			return err
		}
	case *Aggregate_Count_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Count); err != nil {
			return err
		}
	case *Aggregate_Bucket_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bucket); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Aggregate.Aggregate has unexpected type %T", x)
	}
	return nil
}

func _Aggregate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Aggregate)
	switch tag {
	case 1: // aggregate.metric
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Aggregate_Metric)
		err := b.DecodeMessage(msg)
		m.Aggregate = &Aggregate_Metric_{msg}
		return true, err
	case 2: // aggregate.count
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Aggregate_Count)
		err := b.DecodeMessage(msg)
		m.Aggregate = &Aggregate_Count_{msg}
		return true, err
	case 3: // aggregate.bucket
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Aggregate_Bucket)
		err := b.DecodeMessage(msg)
		m.Aggregate = &Aggregate_Bucket_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Aggregate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Aggregate)
	// aggregate
	switch x := m.Aggregate.(type) {
	case *Aggregate_Metric_:
		s := proto.Size(x.Metric)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Aggregate_Count_:
		s := proto.Size(x.Count)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Aggregate_Bucket_:
		s := proto.Size(x.Bucket)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metric calculates numerical information from a field.
type Aggregate_Metric struct {
	// Name of the field to run numerical metrics.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// The type of metric to apply.
	Type Aggregate_Metric_Type `protobuf:"varint,2,opt,name=type,enum=sajari.engine.query.v1.Aggregate_Metric_Type" json:"type,omitempty"`
}

func (m *Aggregate_Metric) Reset()                    { *m = Aggregate_Metric{} }
func (m *Aggregate_Metric) String() string            { return proto.CompactTextString(m) }
func (*Aggregate_Metric) ProtoMessage()               {}
func (*Aggregate_Metric) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *Aggregate_Metric) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Aggregate_Metric) GetType() Aggregate_Metric_Type {
	if m != nil {
		return m.Type
	}
	return Aggregate_Metric_AVG
}

// Count records the number of unique values for a field.
type Aggregate_Count struct {
	// Name of the field to count values from.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
}

func (m *Aggregate_Count) Reset()                    { *m = Aggregate_Count{} }
func (m *Aggregate_Count) String() string            { return proto.CompactTextString(m) }
func (*Aggregate_Count) ProtoMessage()               {}
func (*Aggregate_Count) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 1} }

func (m *Aggregate_Count) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

// Bucket groups records using filters, Records which satisfy the filter
// will be included in the bucket.
type Aggregate_Bucket struct {
	// List of buckets.
	Buckets []*Aggregate_Bucket_Bucket `protobuf:"bytes,1,rep,name=buckets" json:"buckets,omitempty"`
}

func (m *Aggregate_Bucket) Reset()                    { *m = Aggregate_Bucket{} }
func (m *Aggregate_Bucket) String() string            { return proto.CompactTextString(m) }
func (*Aggregate_Bucket) ProtoMessage()               {}
func (*Aggregate_Bucket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 2} }

func (m *Aggregate_Bucket) GetBuckets() []*Aggregate_Bucket_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// Bucket represents records which satisfy a Filter.
type Aggregate_Bucket_Bucket struct {
	// Name of the bucket.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Filter satisfied by records in the bucket.
	Filter *Filter `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
}

func (m *Aggregate_Bucket_Bucket) Reset()                    { *m = Aggregate_Bucket_Bucket{} }
func (m *Aggregate_Bucket_Bucket) String() string            { return proto.CompactTextString(m) }
func (*Aggregate_Bucket_Bucket) ProtoMessage()               {}
func (*Aggregate_Bucket_Bucket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 2, 0} }

func (m *Aggregate_Bucket_Bucket) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Aggregate_Bucket_Bucket) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// Sort defines the ordering of result records using.
type Sort struct {
	// Types that are valid to be assigned to Type:
	//	*Sort_Score
	//	*Sort_QueryScore
	//	*Sort_FeatureScore
	//	*Sort_Field
	Type isSort_Type `protobuf_oneof:"type"`
	// Sorting order.
	Order Sort_Order `protobuf:"varint,5,opt,name=order,enum=sajari.engine.query.v1.Sort_Order" json:"order,omitempty"`
}

func (m *Sort) Reset()                    { *m = Sort{} }
func (m *Sort) String() string            { return proto.CompactTextString(m) }
func (*Sort) ProtoMessage()               {}
func (*Sort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isSort_Type interface {
	isSort_Type()
}

type Sort_Score struct {
	Score bool `protobuf:"varint,1,opt,name=score,oneof"`
}
type Sort_QueryScore struct {
	QueryScore bool `protobuf:"varint,2,opt,name=query_score,json=queryScore,oneof"`
}
type Sort_FeatureScore struct {
	FeatureScore bool `protobuf:"varint,3,opt,name=feature_score,json=featureScore,oneof"`
}
type Sort_Field struct {
	Field string `protobuf:"bytes,4,opt,name=field,oneof"`
}

func (*Sort_Score) isSort_Type()        {}
func (*Sort_QueryScore) isSort_Type()   {}
func (*Sort_FeatureScore) isSort_Type() {}
func (*Sort_Field) isSort_Type()        {}

func (m *Sort) GetType() isSort_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Sort) GetScore() bool {
	if x, ok := m.GetType().(*Sort_Score); ok {
		return x.Score
	}
	return false
}

func (m *Sort) GetQueryScore() bool {
	if x, ok := m.GetType().(*Sort_QueryScore); ok {
		return x.QueryScore
	}
	return false
}

func (m *Sort) GetFeatureScore() bool {
	if x, ok := m.GetType().(*Sort_FeatureScore); ok {
		return x.FeatureScore
	}
	return false
}

func (m *Sort) GetField() string {
	if x, ok := m.GetType().(*Sort_Field); ok {
		return x.Field
	}
	return ""
}

func (m *Sort) GetOrder() Sort_Order {
	if m != nil {
		return m.Order
	}
	return Sort_ASC
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Sort) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Sort_OneofMarshaler, _Sort_OneofUnmarshaler, _Sort_OneofSizer, []interface{}{
		(*Sort_Score)(nil),
		(*Sort_QueryScore)(nil),
		(*Sort_FeatureScore)(nil),
		(*Sort_Field)(nil),
	}
}

func _Sort_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Sort)
	// type
	switch x := m.Type.(type) {
	case *Sort_Score:
		t := uint64(0)
		if x.Score {
			t = 1
		}
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Sort_QueryScore:
		t := uint64(0)
		if x.QueryScore {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Sort_FeatureScore:
		t := uint64(0)
		if x.FeatureScore {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Sort_Field:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Field)
	case nil:
	default:
		return fmt.Errorf("Sort.Type has unexpected type %T", x)
	}
	return nil
}

func _Sort_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Sort)
	switch tag {
	case 1: // type.score
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &Sort_Score{x != 0}
		return true, err
	case 2: // type.query_score
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &Sort_QueryScore{x != 0}
		return true, err
	case 3: // type.feature_score
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &Sort_FeatureScore{x != 0}
		return true, err
	case 4: // type.field
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &Sort_Field{x}
		return true, err
	default:
		return false, nil
	}
}

func _Sort_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Sort)
	// type
	switch x := m.Type.(type) {
	case *Sort_Score:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *Sort_QueryScore:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *Sort_FeatureScore:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *Sort_Field:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Field)))
		n += len(x.Field)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Filter describes a set of conditions to match values in record fields.
// Filters can be nested and combined using Combinators.
type Filter struct {
	// Types that are valid to be assigned to Filter:
	//	*Filter_Combinator_
	//	*Filter_Field_
	//	*Filter_Geo_
	Filter isFilter_Filter `protobuf_oneof:"filter"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isFilter_Filter interface {
	isFilter_Filter()
}

type Filter_Combinator_ struct {
	Combinator *Filter_Combinator `protobuf:"bytes,1,opt,name=combinator,oneof"`
}
type Filter_Field_ struct {
	Field *Filter_Field `protobuf:"bytes,2,opt,name=field,oneof"`
}
type Filter_Geo_ struct {
	Geo *Filter_Geo `protobuf:"bytes,3,opt,name=geo,oneof"`
}

func (*Filter_Combinator_) isFilter_Filter() {}
func (*Filter_Field_) isFilter_Filter()      {}
func (*Filter_Geo_) isFilter_Filter()        {}

func (m *Filter) GetFilter() isFilter_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *Filter) GetCombinator() *Filter_Combinator {
	if x, ok := m.GetFilter().(*Filter_Combinator_); ok {
		return x.Combinator
	}
	return nil
}

func (m *Filter) GetField() *Filter_Field {
	if x, ok := m.GetFilter().(*Filter_Field_); ok {
		return x.Field
	}
	return nil
}

func (m *Filter) GetGeo() *Filter_Geo {
	if x, ok := m.GetFilter().(*Filter_Geo_); ok {
		return x.Geo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Filter) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Filter_OneofMarshaler, _Filter_OneofUnmarshaler, _Filter_OneofSizer, []interface{}{
		(*Filter_Combinator_)(nil),
		(*Filter_Field_)(nil),
		(*Filter_Geo_)(nil),
	}
}

func _Filter_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Filter)
	// filter
	switch x := m.Filter.(type) {
	case *Filter_Combinator_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Combinator); err != nil {
			return err
		}
	case *Filter_Field_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Field); err != nil {
			return err
		}
	case *Filter_Geo_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Geo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Filter.Filter has unexpected type %T", x)
	}
	return nil
}

func _Filter_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Filter)
	switch tag {
	case 1: // filter.combinator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Filter_Combinator)
		err := b.DecodeMessage(msg)
		m.Filter = &Filter_Combinator_{msg}
		return true, err
	case 2: // filter.field
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Filter_Field)
		err := b.DecodeMessage(msg)
		m.Filter = &Filter_Field_{msg}
		return true, err
	case 3: // filter.geo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Filter_Geo)
		err := b.DecodeMessage(msg)
		m.Filter = &Filter_Geo_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Filter_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Filter)
	// filter
	switch x := m.Filter.(type) {
	case *Filter_Combinator_:
		s := proto.Size(x.Combinator)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filter_Field_:
		s := proto.Size(x.Field)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filter_Geo_:
		s := proto.Size(x.Geo)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Field is a filter which is applied to a record field.
type Filter_Field struct {
	// The comparison operator to use.
	Operator Filter_Field_Operator `protobuf:"varint,1,opt,name=operator,enum=sajari.engine.query.v1.Filter_Field_Operator" json:"operator,omitempty"`
	// Field to take values from.
	Field string `protobuf:"bytes,2,opt,name=field" json:"field,omitempty"`
	// Value to match against.
	Value *sajari_engine.Value `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *Filter_Field) Reset()                    { *m = Filter_Field{} }
func (m *Filter_Field) String() string            { return proto.CompactTextString(m) }
func (*Filter_Field) ProtoMessage()               {}
func (*Filter_Field) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *Filter_Field) GetOperator() Filter_Field_Operator {
	if m != nil {
		return m.Operator
	}
	return Filter_Field_EQUAL_TO
}

func (m *Filter_Field) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Filter_Field) GetValue() *sajari_engine.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Geo is a geo-based filter for records with lat/lng fields representing a location.
type Filter_Geo struct {
	// Field containing latitude (degrees).
	FieldLat string `protobuf:"bytes,1,opt,name=field_lat,json=fieldLat" json:"field_lat,omitempty"`
	// Field containing longitude (degrees).
	FieldLng string `protobuf:"bytes,2,opt,name=field_lng,json=fieldLng" json:"field_lng,omitempty"`
	// Target latitude (in degrees).
	Lat float64 `protobuf:"fixed64,3,opt,name=lat" json:"lat,omitempty"`
	// Target longitude (in degrees).
	Lng float64 `protobuf:"fixed64,4,opt,name=lng" json:"lng,omitempty"`
	// Radius (in km) of matching border (see region).
	Radius float64 `protobuf:"fixed64,5,opt,name=radius" json:"radius,omitempty"`
	// Region for matching points.
	Region Filter_Geo_Region `protobuf:"varint,6,opt,name=region,enum=sajari.engine.query.v1.Filter_Geo_Region" json:"region,omitempty"`
}

func (m *Filter_Geo) Reset()                    { *m = Filter_Geo{} }
func (m *Filter_Geo) String() string            { return proto.CompactTextString(m) }
func (*Filter_Geo) ProtoMessage()               {}
func (*Filter_Geo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1} }

func (m *Filter_Geo) GetFieldLat() string {
	if m != nil {
		return m.FieldLat
	}
	return ""
}

func (m *Filter_Geo) GetFieldLng() string {
	if m != nil {
		return m.FieldLng
	}
	return ""
}

func (m *Filter_Geo) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *Filter_Geo) GetLng() float64 {
	if m != nil {
		return m.Lng
	}
	return 0
}

func (m *Filter_Geo) GetRadius() float64 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *Filter_Geo) GetRegion() Filter_Geo_Region {
	if m != nil {
		return m.Region
	}
	return Filter_Geo_INSIDE
}

// Combinator is a filter which combines other filters.
type Filter_Combinator struct {
	// The operator used to combine filters.
	Operator Filter_Combinator_Operator `protobuf:"varint,1,opt,name=operator,enum=sajari.engine.query.v1.Filter_Combinator_Operator" json:"operator,omitempty"`
	// The set of filters to combine using the specified Operator.
	Filters []*Filter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
}

func (m *Filter_Combinator) Reset()                    { *m = Filter_Combinator{} }
func (m *Filter_Combinator) String() string            { return proto.CompactTextString(m) }
func (*Filter_Combinator) ProtoMessage()               {}
func (*Filter_Combinator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 2} }

func (m *Filter_Combinator) GetOperator() Filter_Combinator_Operator {
	if m != nil {
		return m.Operator
	}
	return Filter_Combinator_ALL
}

func (m *Filter_Combinator) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// FieldBoost is used to influence the score of a record based on its field values.
//
// The effect of a FieldBoost is the value that it contributes to the overall score.
// All boost effects are between 0 and 1 inclusive.
type FieldBoost struct {
	// Types that are valid to be assigned to FieldBoost:
	//	*FieldBoost_Filter_
	//	*FieldBoost_Interval_
	//	*FieldBoost_Element_
	//	*FieldBoost_Text_
	FieldBoost isFieldBoost_FieldBoost `protobuf_oneof:"field_boost"`
}

func (m *FieldBoost) Reset()                    { *m = FieldBoost{} }
func (m *FieldBoost) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost) ProtoMessage()               {}
func (*FieldBoost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isFieldBoost_FieldBoost interface {
	isFieldBoost_FieldBoost()
}

type FieldBoost_Filter_ struct {
	Filter *FieldBoost_Filter `protobuf:"bytes,1,opt,name=filter,oneof"`
}
type FieldBoost_Interval_ struct {
	Interval *FieldBoost_Interval `protobuf:"bytes,2,opt,name=interval,oneof"`
}
type FieldBoost_Element_ struct {
	Element *FieldBoost_Element `protobuf:"bytes,3,opt,name=element,oneof"`
}
type FieldBoost_Text_ struct {
	Text *FieldBoost_Text `protobuf:"bytes,4,opt,name=text,oneof"`
}

func (*FieldBoost_Filter_) isFieldBoost_FieldBoost()   {}
func (*FieldBoost_Interval_) isFieldBoost_FieldBoost() {}
func (*FieldBoost_Element_) isFieldBoost_FieldBoost()  {}
func (*FieldBoost_Text_) isFieldBoost_FieldBoost()     {}

func (m *FieldBoost) GetFieldBoost() isFieldBoost_FieldBoost {
	if m != nil {
		return m.FieldBoost
	}
	return nil
}

func (m *FieldBoost) GetFilter() *FieldBoost_Filter {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Filter_); ok {
		return x.Filter
	}
	return nil
}

func (m *FieldBoost) GetInterval() *FieldBoost_Interval {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Interval_); ok {
		return x.Interval
	}
	return nil
}

func (m *FieldBoost) GetElement() *FieldBoost_Element {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Element_); ok {
		return x.Element
	}
	return nil
}

func (m *FieldBoost) GetText() *FieldBoost_Text {
	if x, ok := m.GetFieldBoost().(*FieldBoost_Text_); ok {
		return x.Text
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FieldBoost) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FieldBoost_OneofMarshaler, _FieldBoost_OneofUnmarshaler, _FieldBoost_OneofSizer, []interface{}{
		(*FieldBoost_Filter_)(nil),
		(*FieldBoost_Interval_)(nil),
		(*FieldBoost_Element_)(nil),
		(*FieldBoost_Text_)(nil),
	}
}

func _FieldBoost_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FieldBoost)
	// field_boost
	switch x := m.FieldBoost.(type) {
	case *FieldBoost_Filter_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Filter); err != nil {
			return err
		}
	case *FieldBoost_Interval_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Interval); err != nil {
			return err
		}
	case *FieldBoost_Element_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Element); err != nil {
			return err
		}
	case *FieldBoost_Text_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Text); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FieldBoost.FieldBoost has unexpected type %T", x)
	}
	return nil
}

func _FieldBoost_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FieldBoost)
	switch tag {
	case 1: // field_boost.filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Filter)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Filter_{msg}
		return true, err
	case 2: // field_boost.interval
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Interval)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Interval_{msg}
		return true, err
	case 3: // field_boost.element
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Element)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Element_{msg}
		return true, err
	case 4: // field_boost.text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FieldBoost_Text)
		err := b.DecodeMessage(msg)
		m.FieldBoost = &FieldBoost_Text_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FieldBoost_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FieldBoost)
	// field_boost
	switch x := m.FieldBoost.(type) {
	case *FieldBoost_Filter_:
		s := proto.Size(x.Filter)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldBoost_Interval_:
		s := proto.Size(x.Interval)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldBoost_Element_:
		s := proto.Size(x.Element)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldBoost_Text_:
		s := proto.Size(x.Text)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Filter is a boost applied to records which satisfy a filter.
type FieldBoost_Filter struct {
	// Filter which must be satisfied by record.
	Filter *Filter `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
	// Boost value to apply to matching records. Must be >= 0.
	//
	// Value == 0     Matching records get 0 for this boost, everything else gets 1.
	// Value == 1     Matching records get 1 for this boost, everything else gets 0.
	// 0 < Value < 1  Matching records get Value for this boost (and are penalised).
	// Value > 1      Matching records get 1 for this boost, everything else gets 1 / Value.
	Value float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *FieldBoost_Filter) Reset()                    { *m = FieldBoost_Filter{} }
func (m *FieldBoost_Filter) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Filter) ProtoMessage()               {}
func (*FieldBoost_Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *FieldBoost_Filter) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *FieldBoost_Filter) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Interval is a distance-based boost for numeric fields.
//
// It is comprised of a series of points to represent
// any linear distribution across a numerical range.
type FieldBoost_Interval struct {
	// Numerical field to apply the boost.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// Points which define intervals boundaries (must be at least 2).
	// Values between internal points are determined linearly.
	Points []*FieldBoost_Interval_Point `protobuf:"bytes,2,rep,name=points" json:"points,omitempty"`
}

func (m *FieldBoost_Interval) Reset()                    { *m = FieldBoost_Interval{} }
func (m *FieldBoost_Interval) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Interval) ProtoMessage()               {}
func (*FieldBoost_Interval) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 1} }

func (m *FieldBoost_Interval) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *FieldBoost_Interval) GetPoints() []*FieldBoost_Interval_Point {
	if m != nil {
		return m.Points
	}
	return nil
}

// Point is a pair (point, value) which defines the boost value
// at a particiular point.
type FieldBoost_Interval_Point struct {
	// The point to mark the beginning/end of an interval.
	Point float64 `protobuf:"fixed64,1,opt,name=point" json:"point,omitempty"`
	// The amount to boost by at this Point.
	Value float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *FieldBoost_Interval_Point) Reset()                    { *m = FieldBoost_Interval_Point{} }
func (m *FieldBoost_Interval_Point) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Interval_Point) ProtoMessage()               {}
func (*FieldBoost_Interval_Point) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 1, 0} }

func (m *FieldBoost_Interval_Point) GetPoint() float64 {
	if m != nil {
		return m.Point
	}
	return 0
}

func (m *FieldBoost_Interval_Point) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Element is an element-based boost for repeated fields.
//
// The boost is evaluated as a portion of a list of values which appear
// in the record field.
//
// Boost effect: between 0 and 1.
type FieldBoost_Element struct {
	// Field containing stringArray.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// List of elements to compare against the field values.
	Elts []string `protobuf:"bytes,3,rep,name=elts" json:"elts,omitempty"`
}

func (m *FieldBoost_Element) Reset()                    { *m = FieldBoost_Element{} }
func (m *FieldBoost_Element) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Element) ProtoMessage()               {}
func (*FieldBoost_Element) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 2} }

func (m *FieldBoost_Element) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *FieldBoost_Element) GetElts() []string {
	if m != nil {
		return m.Elts
	}
	return nil
}

// Text represents a text-based boosting for string fields.
//
// Compares text (using a bag of words model) and applies a boost based on the
// number of intersecting words.
//
// Boost effect: between 0 and 1.
type FieldBoost_Text struct {
	// Field containing string data.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// Text to compare against the field value.
	Text string `protobuf:"bytes,3,opt,name=text" json:"text,omitempty"`
}

func (m *FieldBoost_Text) Reset()                    { *m = FieldBoost_Text{} }
func (m *FieldBoost_Text) String() string            { return proto.CompactTextString(m) }
func (*FieldBoost_Text) ProtoMessage()               {}
func (*FieldBoost_Text) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 3} }

func (m *FieldBoost_Text) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *FieldBoost_Text) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// InstanceBoost represents a boosting which is a applied to instances of terms
// in the reverse index.  This type of boost effectively dynamically ranks
// records for a given term
type InstanceBoost struct {
	// Types that are valid to be assigned to InstanceBoost:
	//	*InstanceBoost_Field_
	//	*InstanceBoost_Score_
	InstanceBoost isInstanceBoost_InstanceBoost `protobuf_oneof:"instance_boost"`
}

func (m *InstanceBoost) Reset()                    { *m = InstanceBoost{} }
func (m *InstanceBoost) String() string            { return proto.CompactTextString(m) }
func (*InstanceBoost) ProtoMessage()               {}
func (*InstanceBoost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isInstanceBoost_InstanceBoost interface {
	isInstanceBoost_InstanceBoost()
}

type InstanceBoost_Field_ struct {
	Field *InstanceBoost_Field `protobuf:"bytes,1,opt,name=field,oneof"`
}
type InstanceBoost_Score_ struct {
	Score *InstanceBoost_Score `protobuf:"bytes,2,opt,name=score,oneof"`
}

func (*InstanceBoost_Field_) isInstanceBoost_InstanceBoost() {}
func (*InstanceBoost_Score_) isInstanceBoost_InstanceBoost() {}

func (m *InstanceBoost) GetInstanceBoost() isInstanceBoost_InstanceBoost {
	if m != nil {
		return m.InstanceBoost
	}
	return nil
}

func (m *InstanceBoost) GetField() *InstanceBoost_Field {
	if x, ok := m.GetInstanceBoost().(*InstanceBoost_Field_); ok {
		return x.Field
	}
	return nil
}

func (m *InstanceBoost) GetScore() *InstanceBoost_Score {
	if x, ok := m.GetInstanceBoost().(*InstanceBoost_Score_); ok {
		return x.Score
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstanceBoost) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstanceBoost_OneofMarshaler, _InstanceBoost_OneofUnmarshaler, _InstanceBoost_OneofSizer, []interface{}{
		(*InstanceBoost_Field_)(nil),
		(*InstanceBoost_Score_)(nil),
	}
}

func _InstanceBoost_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstanceBoost)
	// instance_boost
	switch x := m.InstanceBoost.(type) {
	case *InstanceBoost_Field_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Field); err != nil {
			return err
		}
	case *InstanceBoost_Score_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Score); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstanceBoost.InstanceBoost has unexpected type %T", x)
	}
	return nil
}

func _InstanceBoost_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstanceBoost)
	switch tag {
	case 1: // instance_boost.field
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InstanceBoost_Field)
		err := b.DecodeMessage(msg)
		m.InstanceBoost = &InstanceBoost_Field_{msg}
		return true, err
	case 2: // instance_boost.score
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InstanceBoost_Score)
		err := b.DecodeMessage(msg)
		m.InstanceBoost = &InstanceBoost_Score_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstanceBoost_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstanceBoost)
	// instance_boost
	switch x := m.InstanceBoost.(type) {
	case *InstanceBoost_Field_:
		s := proto.Size(x.Field)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstanceBoost_Score_:
		s := proto.Size(x.Score)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Field is an instance boost which is applied to term instances which originate
// from the given meta field.
type InstanceBoost_Field struct {
	// Field where the term instance was defined.
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	// Value to boost terms from this field. A value between 0 and 1 will decrease
	// the score, a value greater than 1 will increase the score.
	Value float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *InstanceBoost_Field) Reset()                    { *m = InstanceBoost_Field{} }
func (m *InstanceBoost_Field) String() string            { return proto.CompactTextString(m) }
func (*InstanceBoost_Field) ProtoMessage()               {}
func (*InstanceBoost_Field) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

func (m *InstanceBoost_Field) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *InstanceBoost_Field) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Score is an instance boost that boosts term instances based on their individual
// scores based on individual interactions.
type InstanceBoost_Score struct {
	// Threshold defines the value after which learning will be applied.  i.e. Only if a learning
	// score is significant enough to be beyond the threshold will it start to take effect.
	Threshold float64 `protobuf:"fixed64,1,opt,name=threshold" json:"threshold,omitempty"`
	// MinCount is the minimum number of interactions required to enable scoring.
	MinCount uint32 `protobuf:"varint,2,opt,name=min_count,json=minCount" json:"min_count,omitempty"`
}

func (m *InstanceBoost_Score) Reset()                    { *m = InstanceBoost_Score{} }
func (m *InstanceBoost_Score) String() string            { return proto.CompactTextString(m) }
func (*InstanceBoost_Score) ProtoMessage()               {}
func (*InstanceBoost_Score) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 1} }

func (m *InstanceBoost_Score) GetThreshold() float64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *InstanceBoost_Score) GetMinCount() uint32 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

// AggregateResponse contains statistical information representing aggregation results
type AggregateResponse struct {
	// Types that are valid to be assigned to AggregateResponse:
	//	*AggregateResponse_Metric_
	//	*AggregateResponse_Count_
	//	*AggregateResponse_Buckets_
	AggregateResponse isAggregateResponse_AggregateResponse `protobuf_oneof:"aggregate_response"`
}

func (m *AggregateResponse) Reset()                    { *m = AggregateResponse{} }
func (m *AggregateResponse) String() string            { return proto.CompactTextString(m) }
func (*AggregateResponse) ProtoMessage()               {}
func (*AggregateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isAggregateResponse_AggregateResponse interface {
	isAggregateResponse_AggregateResponse()
}

type AggregateResponse_Metric_ struct {
	Metric *AggregateResponse_Metric `protobuf:"bytes,1,opt,name=metric,oneof"`
}
type AggregateResponse_Count_ struct {
	Count *AggregateResponse_Count `protobuf:"bytes,2,opt,name=count,oneof"`
}
type AggregateResponse_Buckets_ struct {
	Buckets *AggregateResponse_Buckets `protobuf:"bytes,3,opt,name=buckets,oneof"`
}

func (*AggregateResponse_Metric_) isAggregateResponse_AggregateResponse()  {}
func (*AggregateResponse_Count_) isAggregateResponse_AggregateResponse()   {}
func (*AggregateResponse_Buckets_) isAggregateResponse_AggregateResponse() {}

func (m *AggregateResponse) GetAggregateResponse() isAggregateResponse_AggregateResponse {
	if m != nil {
		return m.AggregateResponse
	}
	return nil
}

func (m *AggregateResponse) GetMetric() *AggregateResponse_Metric {
	if x, ok := m.GetAggregateResponse().(*AggregateResponse_Metric_); ok {
		return x.Metric
	}
	return nil
}

func (m *AggregateResponse) GetCount() *AggregateResponse_Count {
	if x, ok := m.GetAggregateResponse().(*AggregateResponse_Count_); ok {
		return x.Count
	}
	return nil
}

func (m *AggregateResponse) GetBuckets() *AggregateResponse_Buckets {
	if x, ok := m.GetAggregateResponse().(*AggregateResponse_Buckets_); ok {
		return x.Buckets
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AggregateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AggregateResponse_OneofMarshaler, _AggregateResponse_OneofUnmarshaler, _AggregateResponse_OneofSizer, []interface{}{
		(*AggregateResponse_Metric_)(nil),
		(*AggregateResponse_Count_)(nil),
		(*AggregateResponse_Buckets_)(nil),
	}
}

func _AggregateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AggregateResponse)
	// aggregate_response
	switch x := m.AggregateResponse.(type) {
	case *AggregateResponse_Metric_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metric); err != nil {
			return err
		}
	case *AggregateResponse_Count_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Count); err != nil {
			return err
		}
	case *AggregateResponse_Buckets_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Buckets); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AggregateResponse.AggregateResponse has unexpected type %T", x)
	}
	return nil
}

func _AggregateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AggregateResponse)
	switch tag {
	case 1: // aggregate_response.metric
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AggregateResponse_Metric)
		err := b.DecodeMessage(msg)
		m.AggregateResponse = &AggregateResponse_Metric_{msg}
		return true, err
	case 2: // aggregate_response.count
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AggregateResponse_Count)
		err := b.DecodeMessage(msg)
		m.AggregateResponse = &AggregateResponse_Count_{msg}
		return true, err
	case 3: // aggregate_response.buckets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AggregateResponse_Buckets)
		err := b.DecodeMessage(msg)
		m.AggregateResponse = &AggregateResponse_Buckets_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AggregateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AggregateResponse)
	// aggregate_response
	switch x := m.AggregateResponse.(type) {
	case *AggregateResponse_Metric_:
		s := proto.Size(x.Metric)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AggregateResponse_Count_:
		s := proto.Size(x.Count)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AggregateResponse_Buckets_:
		s := proto.Size(x.Buckets)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metric represents the metric type requested, represented by an Enumeration Type.
type AggregateResponse_Metric struct {
	Value float64 `protobuf:"fixed64,1,opt,name=value" json:"value,omitempty"`
}

func (m *AggregateResponse_Metric) Reset()                    { *m = AggregateResponse_Metric{} }
func (m *AggregateResponse_Metric) String() string            { return proto.CompactTextString(m) }
func (*AggregateResponse_Metric) ProtoMessage()               {}
func (*AggregateResponse_Metric) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

func (m *AggregateResponse_Metric) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Count contains the counts for the set of values returned
type AggregateResponse_Count struct {
	Counts map[string]int32 `protobuf:"bytes,1,rep,name=counts" json:"counts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *AggregateResponse_Count) Reset()                    { *m = AggregateResponse_Count{} }
func (m *AggregateResponse_Count) String() string            { return proto.CompactTextString(m) }
func (*AggregateResponse_Count) ProtoMessage()               {}
func (*AggregateResponse_Count) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 1} }

func (m *AggregateResponse_Count) GetCounts() map[string]int32 {
	if m != nil {
		return m.Counts
	}
	return nil
}

// Buckets is a full set of buckets computed in an aggregation.
type AggregateResponse_Buckets struct {
	Buckets map[string]*AggregateResponse_Buckets_Bucket `protobuf:"bytes,1,rep,name=buckets" json:"buckets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AggregateResponse_Buckets) Reset()                    { *m = AggregateResponse_Buckets{} }
func (m *AggregateResponse_Buckets) String() string            { return proto.CompactTextString(m) }
func (*AggregateResponse_Buckets) ProtoMessage()               {}
func (*AggregateResponse_Buckets) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 2} }

func (m *AggregateResponse_Buckets) GetBuckets() map[string]*AggregateResponse_Buckets_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// Bucket is the result of a bucket aggregate.
type AggregateResponse_Buckets_Bucket struct {
	// Name of bucket.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Number of records in the bucket.
	Count int32 `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
}

func (m *AggregateResponse_Buckets_Bucket) Reset()         { *m = AggregateResponse_Buckets_Bucket{} }
func (m *AggregateResponse_Buckets_Bucket) String() string { return proto.CompactTextString(m) }
func (*AggregateResponse_Buckets_Bucket) ProtoMessage()    {}
func (*AggregateResponse_Buckets_Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 2, 0}
}

func (m *AggregateResponse_Buckets_Bucket) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AggregateResponse_Buckets_Bucket) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// SearchResponse contains all data in response to a search request.
type SearchResponse struct {
	// Number of reverse indexes read during the search request.
	Reads int64 `protobuf:"varint,1,opt,name=reads" json:"reads,omitempty"`
	// Total number of results.
	TotalResults int64 `protobuf:"varint,2,opt,name=total_results,json=totalResults" json:"total_results,omitempty"`
	// Time taken to perform query.
	Time string `protobuf:"bytes,3,opt,name=time" json:"time,omitempty"`
	// Aggregates returned by query.
	Aggregates map[string]*AggregateResponse `protobuf:"bytes,4,rep,name=aggregates" json:"aggregates,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Results returned by query.
	Results []*Result `protobuf:"bytes,5,rep,name=results" json:"results,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SearchResponse) GetReads() int64 {
	if m != nil {
		return m.Reads
	}
	return 0
}

func (m *SearchResponse) GetTotalResults() int64 {
	if m != nil {
		return m.TotalResults
	}
	return 0
}

func (m *SearchResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *SearchResponse) GetAggregates() map[string]*AggregateResponse {
	if m != nil {
		return m.Aggregates
	}
	return nil
}

func (m *SearchResponse) GetResults() []*Result {
	if m != nil {
		return m.Results
	}
	return nil
}

// Result is a record as represented in a search result.
type Result struct {
	// Meta data in field-value pairs.
	Values map[string]*sajari_engine.Value `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Score (normalised) attributed to this record.
	// Combines the index score and feature score.
	Score float64 `protobuf:"fixed64,2,opt,name=score" json:"score,omitempty"`
	// Index score.
	IndexScore float64 `protobuf:"fixed64,3,opt,name=index_score,json=indexScore" json:"index_score,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Result) GetValues() map[string]*sajari_engine.Value {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *Result) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Result) GetIndexScore() float64 {
	if m != nil {
		return m.IndexScore
	}
	return 0
}

// AnalyseRequest applies a search request to a record.
type AnalyseRequest struct {
	// Request is a search request which should be applied against a record
	// in the store.
	SearchRequest *SearchRequest `protobuf:"bytes,1,opt,name=search_request,json=searchRequest" json:"search_request,omitempty"`
	// Key is a unique identifier corresponding to a record in the store.
	Keys []*sajari_engine1.Key `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
}

func (m *AnalyseRequest) Reset()                    { *m = AnalyseRequest{} }
func (m *AnalyseRequest) String() string            { return proto.CompactTextString(m) }
func (*AnalyseRequest) ProtoMessage()               {}
func (*AnalyseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AnalyseRequest) GetSearchRequest() *SearchRequest {
	if m != nil {
		return m.SearchRequest
	}
	return nil
}

func (m *AnalyseRequest) GetKeys() []*sajari_engine1.Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

// AnalyseResponse contains the analysis of the record against the query
// request.
type AnalyseResponse struct {
	// Terms is the list of intersecting terms between the record and the
	// search query request.
	Terms []*AnalyseResponse_Terms `protobuf:"bytes,1,rep,name=terms" json:"terms,omitempty"`
	// Status corresponding to each key in the request.
	Status []*sajari_rpc.Status `protobuf:"bytes,2,rep,name=status" json:"status,omitempty"`
}

func (m *AnalyseResponse) Reset()                    { *m = AnalyseResponse{} }
func (m *AnalyseResponse) String() string            { return proto.CompactTextString(m) }
func (*AnalyseResponse) ProtoMessage()               {}
func (*AnalyseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *AnalyseResponse) GetTerms() []*AnalyseResponse_Terms {
	if m != nil {
		return m.Terms
	}
	return nil
}

func (m *AnalyseResponse) GetStatus() []*sajari_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Terms is a list of terms which overlap for a particular record.
type AnalyseResponse_Terms struct {
	Terms []string `protobuf:"bytes,1,rep,name=terms" json:"terms,omitempty"`
}

func (m *AnalyseResponse_Terms) Reset()                    { *m = AnalyseResponse_Terms{} }
func (m *AnalyseResponse_Terms) String() string            { return proto.CompactTextString(m) }
func (*AnalyseResponse_Terms) ProtoMessage()               {}
func (*AnalyseResponse_Terms) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 0} }

func (m *AnalyseResponse_Terms) GetTerms() []string {
	if m != nil {
		return m.Terms
	}
	return nil
}

func init() {
	proto.RegisterType((*SearchRequest)(nil), "sajari.engine.query.v1.SearchRequest")
	proto.RegisterType((*SearchRequest_IndexQuery)(nil), "sajari.engine.query.v1.SearchRequest.IndexQuery")
	proto.RegisterType((*SearchRequest_FeatureQuery)(nil), "sajari.engine.query.v1.SearchRequest.FeatureQuery")
	proto.RegisterType((*SearchRequest_FeatureQuery_FieldBoost)(nil), "sajari.engine.query.v1.SearchRequest.FeatureQuery.FieldBoost")
	proto.RegisterType((*Transform)(nil), "sajari.engine.query.v1.Transform")
	proto.RegisterType((*Term)(nil), "sajari.engine.query.v1.Term")
	proto.RegisterType((*EvaluateRequest)(nil), "sajari.engine.query.v1.EvaluateRequest")
	proto.RegisterType((*SubstituteRequest)(nil), "sajari.engine.query.v1.SubstituteRequest")
	proto.RegisterType((*Body)(nil), "sajari.engine.query.v1.Body")
	proto.RegisterType((*Aggregate)(nil), "sajari.engine.query.v1.Aggregate")
	proto.RegisterType((*Aggregate_Metric)(nil), "sajari.engine.query.v1.Aggregate.Metric")
	proto.RegisterType((*Aggregate_Count)(nil), "sajari.engine.query.v1.Aggregate.Count")
	proto.RegisterType((*Aggregate_Bucket)(nil), "sajari.engine.query.v1.Aggregate.Bucket")
	proto.RegisterType((*Aggregate_Bucket_Bucket)(nil), "sajari.engine.query.v1.Aggregate.Bucket.Bucket")
	proto.RegisterType((*Sort)(nil), "sajari.engine.query.v1.Sort")
	proto.RegisterType((*Filter)(nil), "sajari.engine.query.v1.Filter")
	proto.RegisterType((*Filter_Field)(nil), "sajari.engine.query.v1.Filter.Field")
	proto.RegisterType((*Filter_Geo)(nil), "sajari.engine.query.v1.Filter.Geo")
	proto.RegisterType((*Filter_Combinator)(nil), "sajari.engine.query.v1.Filter.Combinator")
	proto.RegisterType((*FieldBoost)(nil), "sajari.engine.query.v1.FieldBoost")
	proto.RegisterType((*FieldBoost_Filter)(nil), "sajari.engine.query.v1.FieldBoost.Filter")
	proto.RegisterType((*FieldBoost_Interval)(nil), "sajari.engine.query.v1.FieldBoost.Interval")
	proto.RegisterType((*FieldBoost_Interval_Point)(nil), "sajari.engine.query.v1.FieldBoost.Interval.Point")
	proto.RegisterType((*FieldBoost_Element)(nil), "sajari.engine.query.v1.FieldBoost.Element")
	proto.RegisterType((*FieldBoost_Text)(nil), "sajari.engine.query.v1.FieldBoost.Text")
	proto.RegisterType((*InstanceBoost)(nil), "sajari.engine.query.v1.InstanceBoost")
	proto.RegisterType((*InstanceBoost_Field)(nil), "sajari.engine.query.v1.InstanceBoost.Field")
	proto.RegisterType((*InstanceBoost_Score)(nil), "sajari.engine.query.v1.InstanceBoost.Score")
	proto.RegisterType((*AggregateResponse)(nil), "sajari.engine.query.v1.AggregateResponse")
	proto.RegisterType((*AggregateResponse_Metric)(nil), "sajari.engine.query.v1.AggregateResponse.Metric")
	proto.RegisterType((*AggregateResponse_Count)(nil), "sajari.engine.query.v1.AggregateResponse.Count")
	proto.RegisterType((*AggregateResponse_Buckets)(nil), "sajari.engine.query.v1.AggregateResponse.Buckets")
	proto.RegisterType((*AggregateResponse_Buckets_Bucket)(nil), "sajari.engine.query.v1.AggregateResponse.Buckets.Bucket")
	proto.RegisterType((*SearchResponse)(nil), "sajari.engine.query.v1.SearchResponse")
	proto.RegisterType((*Result)(nil), "sajari.engine.query.v1.Result")
	proto.RegisterType((*AnalyseRequest)(nil), "sajari.engine.query.v1.AnalyseRequest")
	proto.RegisterType((*AnalyseResponse)(nil), "sajari.engine.query.v1.AnalyseResponse")
	proto.RegisterType((*AnalyseResponse_Terms)(nil), "sajari.engine.query.v1.AnalyseResponse.Terms")
	proto.RegisterEnum("sajari.engine.query.v1.Aggregate_Metric_Type", Aggregate_Metric_Type_name, Aggregate_Metric_Type_value)
	proto.RegisterEnum("sajari.engine.query.v1.Sort_Order", Sort_Order_name, Sort_Order_value)
	proto.RegisterEnum("sajari.engine.query.v1.Filter_Field_Operator", Filter_Field_Operator_name, Filter_Field_Operator_value)
	proto.RegisterEnum("sajari.engine.query.v1.Filter_Geo_Region", Filter_Geo_Region_name, Filter_Geo_Region_value)
	proto.RegisterEnum("sajari.engine.query.v1.Filter_Combinator_Operator", Filter_Combinator_Operator_name, Filter_Combinator_Operator_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Query service

type QueryClient interface {
	// Search runs a search query over all records in a collection.
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// Evaluate runs a search query on a single record in a collection.
	Evaluate(ctx context.Context, in *EvaluateRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// Substitute takes a search request and a record and substitutes the record values
	// in the request.
	Substitute(ctx context.Context, in *SubstituteRequest, opts ...grpc.CallOption) (*SearchRequest, error)
	// Analyse takes an AnalyseRequest (comprised of a search query and a record identifier)
	// and computes the term overlap between the two.
	Analyse(ctx context.Context, in *AnalyseRequest, opts ...grpc.CallOption) (*AnalyseResponse, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.query.v1.Query/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Evaluate(ctx context.Context, in *EvaluateRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.query.v1.Query/Evaluate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Substitute(ctx context.Context, in *SubstituteRequest, opts ...grpc.CallOption) (*SearchRequest, error) {
	out := new(SearchRequest)
	err := grpc.Invoke(ctx, "/sajari.engine.query.v1.Query/Substitute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Analyse(ctx context.Context, in *AnalyseRequest, opts ...grpc.CallOption) (*AnalyseResponse, error) {
	out := new(AnalyseResponse)
	err := grpc.Invoke(ctx, "/sajari.engine.query.v1.Query/Analyse", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Query service

type QueryServer interface {
	// Search runs a search query over all records in a collection.
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	// Evaluate runs a search query on a single record in a collection.
	Evaluate(context.Context, *EvaluateRequest) (*SearchResponse, error)
	// Substitute takes a search request and a record and substitutes the record values
	// in the request.
	Substitute(context.Context, *SubstituteRequest) (*SearchRequest, error)
	// Analyse takes an AnalyseRequest (comprised of a search query and a record identifier)
	// and computes the term overlap between the two.
	Analyse(context.Context, *AnalyseRequest) (*AnalyseResponse, error)
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.query.v1.Query/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Evaluate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Evaluate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.query.v1.Query/Evaluate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Evaluate(ctx, req.(*EvaluateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Substitute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubstituteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Substitute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.query.v1.Query/Substitute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Substitute(ctx, req.(*SubstituteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Analyse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Analyse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sajari.engine.query.v1.Query/Analyse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Analyse(ctx, req.(*AnalyseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sajari.engine.query.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _Query_Search_Handler,
		},
		{
			MethodName: "Evaluate",
			Handler:    _Query_Evaluate_Handler,
		},
		{
			MethodName: "Substitute",
			Handler:    _Query_Substitute_Handler,
		},
		{
			MethodName: "Analyse",
			Handler:    _Query_Analyse_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sajari/engine/query/v1/query.proto",
}

func init() { proto.RegisterFile("sajari/engine/query/v1/query.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2083 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x59, 0xcd, 0x8f, 0x1b, 0x49,
	0x15, 0x9f, 0xb6, 0xdd, 0x6d, 0xfb, 0x79, 0x3c, 0xf1, 0x96, 0x86, 0xe0, 0x6d, 0x42, 0x3e, 0x1a,
	0x92, 0x4c, 0x66, 0x85, 0x27, 0x71, 0x44, 0x18, 0x3e, 0x96, 0x95, 0xed, 0x78, 0x66, 0x4c, 0x66,
	0xec, 0x4d, 0xd9, 0x13, 0x02, 0x48, 0x78, 0x7b, 0xec, 0xb2, 0xa7, 0x89, 0xdd, 0xed, 0xed, 0x6e,
	0x67, 0xe3, 0x23, 0x17, 0x24, 0x0e, 0x7b, 0x43, 0xe2, 0x0a, 0x12, 0x17, 0x6e, 0xfc, 0x01, 0xdc,
	0xe1, 0xc6, 0x05, 0x09, 0x21, 0x24, 0x10, 0x07, 0xfe, 0x08, 0x0e, 0x48, 0xa8, 0xbe, 0xba, 0xdb,
	0x5e, 0x7f, 0xf4, 0xac, 0x08, 0x97, 0x99, 0xae, 0x57, 0xef, 0xf7, 0xea, 0xbd, 0xaa, 0xf7, 0x5e,
	0xbd, 0x57, 0x06, 0xc3, 0x33, 0x7f, 0x62, 0xba, 0xd6, 0x01, 0xb1, 0x87, 0x96, 0x4d, 0x0e, 0x3e,
	0x9e, 0x12, 0x77, 0x76, 0xf0, 0xfa, 0x11, 0xff, 0x28, 0x4d, 0x5c, 0xc7, 0x77, 0xd0, 0x75, 0xce,
	0x53, 0xe2, 0x3c, 0x25, 0x3e, 0xf5, 0xfa, 0x91, 0xfe, 0xee, 0x3c, 0xf6, 0xb5, 0x39, 0x9a, 0x12,
	0x0e, 0xd1, 0xbf, 0x38, 0x3f, 0xf5, 0x8a, 0xcc, 0x16, 0x26, 0xdc, 0x49, 0xef, 0xc0, 0xf3, 0x4d,
	0x7f, 0xea, 0xf1, 0x09, 0xe3, 0x4f, 0x19, 0xc8, 0xb7, 0x89, 0xe9, 0xf6, 0x2e, 0x31, 0xf9, 0x78,
	0x4a, 0x3c, 0x1f, 0x3d, 0x01, 0x6d, 0x60, 0x8d, 0x7c, 0xe2, 0x16, 0x95, 0xdb, 0xca, 0x5e, 0xae,
	0x7c, 0xb3, 0xb4, 0x5c, 0x8f, 0xd2, 0x11, 0xe3, 0xc2, 0x82, 0x1b, 0x3d, 0x87, 0x9c, 0x65, 0xf7,
	0xc9, 0x9b, 0x2e, 0x63, 0x28, 0x26, 0x18, 0xf8, 0xe1, 0x2a, 0xf0, 0xdc, 0x9a, 0xa5, 0x06, 0x05,
	0x3e, 0xa7, 0x73, 0x18, 0xac, 0xe0, 0x1b, 0x7d, 0x1f, 0xf2, 0x03, 0x62, 0xfa, 0x53, 0x97, 0x08,
	0xa1, 0x49, 0x26, 0xb4, 0x1c, 0x4f, 0xe8, 0x11, 0x87, 0x72, 0xb1, 0xdb, 0x83, 0xc8, 0x08, 0x5d,
	0x07, 0xcd, 0x19, 0x0c, 0x3c, 0xe2, 0x17, 0x53, 0xb7, 0x95, 0x3d, 0x15, 0x8b, 0x11, 0xda, 0x05,
	0x75, 0x64, 0x8d, 0x2d, 0xbf, 0xa8, 0x32, 0x32, 0x1f, 0x50, 0xee, 0x81, 0x45, 0x46, 0x7d, 0xaf,
	0xa8, 0xdd, 0x4e, 0xee, 0x65, 0xb1, 0x18, 0xa1, 0x87, 0x90, 0xf2, 0x1c, 0xd7, 0x2f, 0xa6, 0x6f,
	0x27, 0xf7, 0x72, 0xe5, 0x1b, 0x2b, 0xb5, 0x72, 0x5c, 0x1f, 0x33, 0x4e, 0x74, 0x0e, 0x60, 0x0e,
	0x87, 0x2e, 0x19, 0x9a, 0x3e, 0xf1, 0x8a, 0x19, 0x86, 0xfb, 0x7a, 0x3c, 0x6b, 0x2a, 0x01, 0xae,
	0x6e, 0xfb, 0x74, 0x9f, 0x42, 0x41, 0xa8, 0x02, 0xe0, 0xbb, 0xa6, 0xed, 0x0d, 0x1c, 0x77, 0xec,
	0x15, 0xb3, 0x4c, 0xec, 0x9d, 0x55, 0x62, 0x3b, 0x92, 0x13, 0x47, 0x40, 0xfa, 0xcf, 0x13, 0x00,
	0xe1, 0x29, 0x50, 0xd3, 0x2e, 0x9c, 0xfe, 0xac, 0xa8, 0xac, 0x37, 0xad, 0xea, 0xf4, 0x67, 0x98,
	0x71, 0xa2, 0x32, 0xa8, 0x3e, 0xa1, 0xcb, 0x27, 0xd6, 0x43, 0x3a, 0xc4, 0x1d, 0x63, 0xce, 0x8a,
	0x9a, 0x70, 0xcd, 0xb2, 0x3d, 0xdf, 0xb4, 0x7b, 0xa4, 0x7b, 0xe1, 0x38, 0x9e, 0xef, 0x15, 0x93,
	0x0c, 0x7d, 0x77, 0x15, 0xba, 0x21, 0xd8, 0xab, 0x94, 0x1b, 0xef, 0x58, 0xd1, 0xa1, 0x87, 0xea,
	0xb0, 0xcd, 0x8e, 0x46, 0x0a, 0x4b, 0x31, 0x61, 0xc6, 0x6a, 0x07, 0x26, 0xa3, 0x3e, 0x97, 0x94,
	0x1b, 0x04, 0xdf, 0x9e, 0xfe, 0x57, 0x05, 0xb6, 0xa3, 0xce, 0x83, 0x3e, 0x5a, 0x90, 0xcb, 0x77,
	0xe5, 0xfd, 0xab, 0xbb, 0xe1, 0xca, 0x25, 0x87, 0x00, 0xe1, 0x14, 0xaa, 0x41, 0x2e, 0xb2, 0x9e,
	0x88, 0xc3, 0x38, 0x66, 0x40, 0x28, 0x93, 0xfa, 0x32, 0x4b, 0x0d, 0x2c, 0x12, 0x15, 0xcc, 0x07,
	0xfa, 0x47, 0x70, 0x6d, 0xc1, 0x93, 0x50, 0x01, 0x92, 0xaf, 0xc8, 0x8c, 0xad, 0x92, 0xc5, 0xf4,
	0x13, 0x7d, 0x23, 0x0a, 0x5d, 0xe3, 0x4a, 0x81, 0x24, 0x21, 0xfd, 0x5b, 0x89, 0x43, 0xc5, 0x78,
	0x0f, 0xb2, 0x81, 0x8b, 0xa1, 0x9b, 0x00, 0x56, 0x9f, 0xd8, 0xbe, 0x35, 0xb0, 0x44, 0x42, 0xc9,
	0xe2, 0x08, 0xc5, 0xf8, 0x9d, 0x02, 0x29, 0xea, 0x11, 0xa1, 0xb6, 0x9c, 0x87, 0x0f, 0x28, 0x95,
	0x59, 0xc4, 0x14, 0xc9, 0x62, 0x3e, 0xa0, 0x0a, 0x4f, 0x1c, 0x8f, 0x25, 0x83, 0x3c, 0xa6, 0x9f,
	0x94, 0x62, 0x93, 0x21, 0x0b, 0xe6, 0x3c, 0xa6, 0x9f, 0x34, 0x66, 0x3f, 0x21, 0xd6, 0xf0, 0x92,
	0x87, 0xb2, 0x82, 0xc5, 0x08, 0xdd, 0x82, 0xdc, 0x27, 0x8e, 0xdb, 0xef, 0x8a, 0xf0, 0xd7, 0x18,
	0x02, 0x28, 0xa9, 0xc5, 0x53, 0xc0, 0x2d, 0xc8, 0x4d, 0x4c, 0xd7, 0x94, 0x0c, 0x69, 0xce, 0x40,
	0x49, 0x9c, 0xc1, 0xf8, 0x8f, 0x02, 0xd7, 0xea, 0x54, 0x3d, 0x6a, 0xb7, 0xc8, 0x99, 0xa7, 0xb0,
	0xe3, 0xb1, 0x43, 0xef, 0xba, 0x9c, 0x22, 0xce, 0xec, 0x6e, 0x2c, 0x17, 0xc1, 0x79, 0x6f, 0x2e,
	0x03, 0x3f, 0x03, 0xcd, 0x25, 0x3d, 0xc7, 0xed, 0x8b, 0x58, 0x7a, 0xbc, 0x4a, 0xca, 0x82, 0x1a,
	0x25, 0xcc, 0x50, 0x3c, 0x3f, 0x08, 0x11, 0x7a, 0x0b, 0x72, 0x11, 0xf2, 0x92, 0xc3, 0xde, 0x9f,
	0x3f, 0xec, 0xdd, 0x85, 0xc5, 0x5e, 0xd0, 0xb9, 0xe8, 0xf9, 0xfe, 0x34, 0x01, 0xef, 0xb4, 0xa7,
	0x17, 0x9e, 0x6f, 0xf9, 0xd3, 0xb7, 0xb5, 0x03, 0x67, 0x0b, 0x3b, 0xb0, 0x3a, 0x47, 0x2e, 0x2a,
	0xf2, 0xff, 0xd9, 0x83, 0x32, 0xa4, 0x68, 0xea, 0x43, 0x08, 0x52, 0x3e, 0x79, 0xe3, 0x0b, 0x51,
	0xec, 0x3b, 0xe2, 0x79, 0x89, 0xa8, 0xe7, 0x19, 0xbf, 0x4f, 0x41, 0x36, 0x08, 0x18, 0x54, 0x05,
	0x6d, 0x4c, 0x7c, 0xd7, 0xea, 0x89, 0x7d, 0xda, 0xdb, 0x18, 0x63, 0xa5, 0x33, 0xc6, 0x7f, 0xb2,
	0x85, 0x05, 0x12, 0x7d, 0x00, 0x6a, 0xcf, 0x99, 0xda, 0xbe, 0xd0, 0xfa, 0xfe, 0x66, 0x11, 0x35,
	0xca, 0x7e, 0xb2, 0x85, 0x39, 0x8e, 0x2a, 0x71, 0x31, 0xed, 0xbd, 0x22, 0xbe, 0xb8, 0x58, 0x63,
	0x28, 0x51, 0x65, 0xfc, 0x54, 0x09, 0x8e, 0xd4, 0x3f, 0x55, 0x40, 0xe3, 0x9a, 0x85, 0xd1, 0xaa,
	0x44, 0xa3, 0xb5, 0x02, 0x29, 0x7f, 0x36, 0xe1, 0x5b, 0xbb, 0x53, 0xfe, 0x5a, 0x5c, 0x3b, 0x4b,
	0x9d, 0xd9, 0x84, 0x60, 0x06, 0x35, 0xf6, 0x21, 0x45, 0x47, 0x28, 0x0d, 0xc9, 0xca, 0x8b, 0xe3,
	0xc2, 0x16, 0xfd, 0x38, 0x6b, 0x34, 0x0b, 0x0a, 0xfb, 0xa8, 0xbc, 0x2c, 0x24, 0xe8, 0x47, 0xfb,
	0xfc, 0xac, 0x90, 0xd4, 0xbf, 0x0c, 0x2a, 0xb3, 0x72, 0xb9, 0x36, 0xfa, 0x6f, 0x15, 0xd0, 0xb8,
	0x0d, 0xa8, 0x01, 0x69, 0x6e, 0x83, 0x4c, 0xe8, 0x07, 0x71, 0xcd, 0x17, 0xff, 0xb0, 0xc4, 0xeb,
	0x9d, 0x40, 0x28, 0x82, 0x94, 0x6d, 0x8e, 0x65, 0x1a, 0x63, 0xdf, 0x91, 0x8a, 0x2a, 0x71, 0x95,
	0x8a, 0xaa, 0x9a, 0x83, 0x6c, 0x70, 0xc9, 0x1b, 0x7f, 0x57, 0x20, 0x45, 0x2b, 0x09, 0x74, 0x1d,
	0x54, 0xaf, 0xe7, 0xb8, 0x7c, 0x89, 0x0c, 0x3d, 0x4c, 0x36, 0x44, 0x77, 0x20, 0xc7, 0x04, 0x75,
	0xf9, 0x6c, 0x42, 0xcc, 0x02, 0x23, 0xb6, 0x19, 0xcb, 0xdd, 0xb0, 0x9e, 0xe2, 0x4c, 0x49, 0xc1,
	0x24, 0xab, 0x23, 0xce, 0x76, 0x5d, 0xee, 0x1c, 0xcd, 0xa7, 0x59, 0xba, 0x02, 0x3f, 0xc9, 0x43,
	0x50, 0x1d, 0xb7, 0x4f, 0x5c, 0x96, 0x52, 0x77, 0x56, 0x5f, 0x48, 0x54, 0xcd, 0x52, 0x8b, 0x72,
	0x62, 0x0e, 0x30, 0x74, 0x50, 0xd9, 0x98, 0x9d, 0x60, 0xbb, 0x56, 0xd8, 0x42, 0x19, 0x48, 0x3d,
	0xad, 0xb7, 0x6b, 0x05, 0xa5, 0xaa, 0x71, 0xff, 0x30, 0xfe, 0x95, 0x06, 0x8d, 0x6f, 0x00, 0x7a,
	0x06, 0xd0, 0x73, 0xc6, 0x17, 0x96, 0x6d, 0xfa, 0x8e, 0x2c, 0x43, 0x1f, 0xac, 0xdf, 0xb4, 0x52,
	0x2d, 0x00, 0x50, 0xa3, 0x43, 0x38, 0xfa, 0x4e, 0xf4, 0x0e, 0xc9, 0x95, 0xbf, 0xba, 0x41, 0x0e,
	0xbb, 0x4d, 0x43, 0x9b, 0x9f, 0x40, 0x72, 0x48, 0x1c, 0x11, 0x1f, 0xc6, 0x06, 0xec, 0x31, 0x71,
	0x4e, 0xb6, 0x30, 0x05, 0xe8, 0xff, 0x48, 0x80, 0xca, 0x44, 0xa1, 0x06, 0x64, 0x9c, 0x09, 0x71,
	0x03, 0x53, 0xd6, 0xc4, 0x40, 0x54, 0x85, 0x52, 0x4b, 0x80, 0x70, 0x00, 0x5f, 0x71, 0x1d, 0x06,
	0xc9, 0x2b, 0xb9, 0x31, 0x79, 0x19, 0x7f, 0x54, 0x20, 0x23, 0x05, 0xa3, 0x6d, 0xc8, 0xd4, 0x9f,
	0x9f, 0x57, 0x4e, 0xbb, 0x9d, 0x56, 0x61, 0x0b, 0x15, 0x60, 0xbb, 0xd9, 0xea, 0x74, 0x03, 0x8a,
	0x42, 0x29, 0xc7, 0xb8, 0x5e, 0xe9, 0xd4, 0x71, 0xb7, 0x73, 0x52, 0x69, 0x16, 0x12, 0xe8, 0x06,
	0x14, 0xa3, 0x94, 0x6e, 0x0b, 0x87, 0xfc, 0x49, 0x94, 0x87, 0xec, 0x69, 0xbd, 0xdd, 0xe6, 0xcc,
	0x29, 0xf4, 0x2e, 0x7c, 0x21, 0x18, 0xce, 0x71, 0xaa, 0x74, 0xe5, 0x5a, 0xab, 0xd9, 0xa9, 0x34,
	0x9a, 0xed, 0x82, 0x86, 0x76, 0xa1, 0xf0, 0xb4, 0x55, 0x6f, 0x77, 0xe9, 0xf2, 0x82, 0x5c, 0x48,
	0xa3, 0x1d, 0x80, 0x93, 0x4a, 0xbb, 0xdb, 0x3e, 0x3f, 0x3a, 0x6a, 0xbc, 0x2c, 0x64, 0xe4, 0xf8,
	0x43, 0x5c, 0xa7, 0xe3, 0xac, 0xfe, 0x4f, 0x05, 0x92, 0xc7, 0xc4, 0x41, 0x5f, 0x82, 0x2c, 0x2f,
	0x96, 0x46, 0xa6, 0x4c, 0xc4, 0x19, 0x46, 0x38, 0x35, 0xfd, 0xc8, 0xa4, 0x3d, 0x14, 0xbb, 0x26,
	0x26, 0xed, 0x21, 0xbd, 0x07, 0x28, 0x26, 0xc9, 0xd2, 0x34, 0xfd, 0x64, 0x14, 0x9b, 0xd7, 0x11,
	0x94, 0x62, 0xb3, 0x3a, 0xc2, 0x35, 0xfb, 0xd6, 0xd4, 0x93, 0x75, 0x04, 0x1f, 0xa1, 0x0a, 0xbd,
	0xa1, 0x86, 0x96, 0x63, 0xb3, 0x12, 0x62, 0x67, 0xa3, 0x7b, 0x1e, 0x13, 0xa7, 0x84, 0x19, 0x00,
	0x0b, 0xa0, 0x71, 0x07, 0x34, 0x4e, 0x41, 0x00, 0x5a, 0xa3, 0xd9, 0x6e, 0x3c, 0xad, 0x17, 0xb6,
	0x50, 0x0e, 0xd2, 0xad, 0xf3, 0x0e, 0x1b, 0x28, 0xfa, 0x1f, 0x14, 0x80, 0xd0, 0xb1, 0x51, 0xf3,
	0x33, 0xae, 0x54, 0x8e, 0x1d, 0x15, 0xcb, 0xfc, 0xe9, 0x10, 0xd2, 0x3c, 0xd5, 0xc8, 0xaa, 0x7d,
	0x53, 0x66, 0x92, 0xec, 0xc6, 0x41, 0xc4, 0x8d, 0x68, 0x4c, 0x9f, 0x9e, 0xf2, 0xac, 0x5c, 0x69,
	0xfe, 0x80, 0x67, 0xe5, 0x56, 0xb3, 0x5e, 0x48, 0xd0, 0x28, 0x6f, 0xd2, 0xaf, 0x64, 0x35, 0x23,
	0x73, 0xa0, 0xf1, 0x0b, 0x75, 0xa1, 0xd6, 0x9d, 0x6f, 0x37, 0x1f, 0x6c, 0x2e, 0x73, 0x85, 0x36,
	0xf4, 0x12, 0x12, 0xbd, 0x67, 0x03, 0x32, 0x96, 0xed, 0x13, 0xf7, 0xb5, 0x39, 0x12, 0x61, 0xfe,
	0x5e, 0x0c, 0x31, 0x0d, 0x01, 0x39, 0xd9, 0xc2, 0x01, 0x1c, 0x1d, 0x41, 0x9a, 0x8c, 0xc8, 0x98,
	0xd8, 0xf2, 0x52, 0xdc, 0x8f, 0x21, 0xa9, 0xce, 0x11, 0x27, 0x5b, 0x58, 0x82, 0xd1, 0xfb, 0xa2,
	0x34, 0x48, 0xad, 0xbf, 0x9b, 0x23, 0x42, 0x3a, 0xe4, 0x0d, 0x95, 0xc0, 0x60, 0xfa, 0x8b, 0x20,
	0x19, 0x7e, 0xde, 0x7e, 0x7c, 0x79, 0xfd, 0xff, 0x2b, 0x05, 0x32, 0xd2, 0xee, 0x15, 0x17, 0x76,
	0x03, 0xb4, 0x89, 0x63, 0xd9, 0xbe, 0x74, 0x8a, 0x47, 0x57, 0xd8, 0xca, 0xd2, 0x87, 0x14, 0x89,
	0x85, 0x00, 0xfd, 0x31, 0xa8, 0x8c, 0x40, 0x57, 0x62, 0x24, 0xb6, 0x92, 0x82, 0xf9, 0x60, 0x85,
	0x8a, 0x8f, 0x21, 0x2d, 0xf6, 0x73, 0x85, 0x82, 0x08, 0x52, 0x64, 0x24, 0x7a, 0xc5, 0x2c, 0x66,
	0xdf, 0xfa, 0x43, 0xda, 0x47, 0xbc, 0x59, 0x83, 0x60, 0x87, 0x91, 0x0c, 0xeb, 0xb4, 0x6a, 0x7e,
	0xae, 0xc9, 0x32, 0x7e, 0x93, 0x80, 0xfc, 0x5c, 0x77, 0x89, 0x6a, 0x51, 0x51, 0x6b, 0x3c, 0x6a,
	0x0e, 0xb5, 0x78, 0x7f, 0xd4, 0xe4, 0x6d, 0x9d, 0xb8, 0x8a, 0x10, 0x76, 0x0f, 0x07, 0x57, 0x3b,
	0xdd, 0x46, 0x7e, 0x97, 0x2c, 0xb7, 0x6e, 0xf9, 0x36, 0x56, 0x41, 0xe5, 0xd7, 0xf9, 0x0d, 0xc8,
	0xfa, 0x97, 0x2e, 0xf1, 0x2e, 0x1d, 0x01, 0x54, 0x70, 0x48, 0xa0, 0x19, 0x72, 0x6c, 0xd9, 0xdd,
	0xb0, 0x90, 0xcc, 0xe3, 0xcc, 0xd8, 0xb2, 0x59, 0x0d, 0x55, 0x2d, 0xc0, 0xce, 0x7c, 0x83, 0x6e,
	0xfc, 0x45, 0x85, 0x77, 0xc2, 0xb6, 0x8f, 0x78, 0x13, 0xc7, 0xf6, 0x08, 0xfa, 0xde, 0x42, 0x35,
	0xfb, 0x70, 0x73, 0xc7, 0x28, 0xa0, 0x9f, 0xad, 0x6a, 0x8f, 0xe7, 0xab, 0xda, 0x83, 0xf8, 0xa2,
	0x16, 0xaa, 0xdb, 0xb3, 0xb0, 0xbe, 0xe3, 0x91, 0xfc, 0x28, 0xbe, 0x28, 0x5e, 0xcd, 0x79, 0x34,
	0xa0, 0x65, 0x8d, 0x77, 0x33, 0x5a, 0xe7, 0x86, 0xbd, 0x6a, 0xb0, 0xdf, 0xbf, 0x54, 0x64, 0xe5,
	0xd9, 0x06, 0x8d, 0x69, 0x20, 0xeb, 0xca, 0x6f, 0x5f, 0xd1, 0x04, 0xfe, 0x57, 0xbc, 0xf3, 0x08,
	0x51, 0xfa, 0x37, 0x21, 0x17, 0x21, 0x2f, 0xe9, 0x61, 0xe6, 0xbc, 0x40, 0x8d, 0x74, 0x2b, 0xfa,
	0xa7, 0x09, 0x48, 0x0b, 0x83, 0xd0, 0xcb, 0xc5, 0xa2, 0xf7, 0xbb, 0x57, 0xde, 0x14, 0xf9, 0x9f,
	0xeb, 0x17, 0xec, 0x4f, 0x79, 0x6d, 0x0d, 0xbc, 0x1b, 0x3d, 0x55, 0x55, 0x1c, 0x91, 0xee, 0xc3,
	0x76, 0x54, 0xd8, 0x12, 0xab, 0x9a, 0xf3, 0x9d, 0xd9, 0xe1, 0xe7, 0xd5, 0x36, 0xb2, 0x1f, 0xd5,
	0x5d, 0x40, 0x41, 0x5d, 0xdd, 0x75, 0x05, 0xbf, 0xf1, 0xb7, 0x04, 0xec, 0xc8, 0xa6, 0x54, 0xb8,
	0xf5, 0x2e, 0xa8, 0x2e, 0x31, 0xfb, 0x1e, 0x53, 0x28, 0x89, 0xf9, 0x00, 0x7d, 0x05, 0xf2, 0xbe,
	0xe3, 0x9b, 0x23, 0x0a, 0x9d, 0x8e, 0x58, 0x9a, 0xa4, 0xb3, 0xdb, 0x8c, 0x88, 0x39, 0x8d, 0x65,
	0x1c, 0x6b, 0x4c, 0x82, 0x8c, 0x63, 0x8d, 0x09, 0x7a, 0x31, 0xf7, 0xfa, 0xc7, 0x1f, 0xa7, 0x9e,
	0x6c, 0xea, 0x8f, 0x85, 0x35, 0xeb, 0x9e, 0xff, 0x0e, 0x21, 0x2d, 0x55, 0x51, 0xd7, 0x5f, 0xe3,
	0x5c, 0x3b, 0x2c, 0xd9, 0xf5, 0xcb, 0x38, 0xaf, 0x41, 0x1f, 0xcc, 0x1f, 0xc1, 0x83, 0xd8, 0x47,
	0x10, 0xed, 0x98, 0xff, 0xac, 0xd0, 0x6a, 0x87, 0xae, 0x4a, 0xbb, 0x4e, 0x46, 0x97, 0x1e, 0xb8,
	0xbf, 0x5e, 0x5b, 0x5e, 0xc0, 0xca, 0x68, 0xe0, 0x48, 0x7a, 0x32, 0x61, 0x5a, 0x55, 0x64, 0x0b,
	0x74, 0x4b, 0x3e, 0x41, 0x87, 0xdd, 0x8d, 0x22, 0x1e, 0x94, 0x59, 0x2a, 0xd4, 0x5b, 0x90, 0x8b,
	0x48, 0xfb, 0x1f, 0x3c, 0x04, 0xfc, 0x4c, 0x81, 0x9d, 0x8a, 0x6d, 0x8e, 0x66, 0xde, 0x5b, 0x7a,
	0x09, 0xb9, 0x07, 0xa9, 0x57, 0x64, 0x26, 0xaf, 0x62, 0xb4, 0x20, 0xe3, 0x19, 0x99, 0x61, 0x36,
	0x6f, 0xfc, 0x5a, 0x81, 0x6b, 0x81, 0x22, 0xc2, 0x7d, 0x6b, 0xf2, 0x49, 0x96, 0xef, 0xf3, 0xea,
	0xd6, 0x7b, 0x1e, 0xc7, 0x9e, 0x68, 0x3d, 0xf9, 0x46, 0xbb, 0x0f, 0x1a, 0xff, 0xc1, 0x60, 0x51,
	0x05, 0x77, 0xd2, 0x2b, 0xb5, 0xd9, 0x0c, 0x16, 0x1c, 0xb4, 0xf7, 0x66, 0x58, 0x7a, 0x3c, 0xe1,
	0xca, 0x59, 0x21, 0xaa, 0xfc, 0xef, 0x04, 0xa8, 0xf2, 0x61, 0x5f, 0xe3, 0x56, 0xa3, 0x78, 0xbb,
	0xa2, 0xdf, 0x8b, 0x17, 0x26, 0xe8, 0x47, 0x90, 0x91, 0x8f, 0x62, 0xe8, 0x7e, 0xcc, 0x67, 0xb3,
	0xd8, 0xc2, 0x7f, 0x0c, 0x10, 0xbe, 0x37, 0xa1, 0x07, 0xb1, 0xdf, 0xa4, 0xf4, 0x78, 0x46, 0xa2,
	0x1f, 0x42, 0x5a, 0x1c, 0x05, 0xba, 0xb7, 0xf1, 0xac, 0xb8, 0xe4, 0xfb, 0x31, 0xcf, 0xf4, 0x42,
	0x63, 0x3f, 0xf7, 0x3c, 0xfe, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe4, 0xd0, 0x26, 0xa6, 0x79,
	0x1a, 0x00, 0x00,
}
